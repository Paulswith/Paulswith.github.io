<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Paulswith·__dobby&#39;s Blogs</title>
  
  <subtitle>I just wanna improve myself.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-24T18:57:29.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Paulswith __dobby</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器学习迁移模型到IOS</title>
    <link href="http://yoursite.com/2018/02/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%BF%81%E7%A7%BB%E6%A8%A1%E5%9E%8B%E5%88%B0IOS/"/>
    <id>http://yoursite.com/2018/02/25/机器学习迁移模型到IOS/</id>
    <published>2018-02-24T17:01:47.000Z</published>
    <updated>2018-02-24T18:57:29.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://paulswith.github.io/2018/02/24/%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0InceptionV3/" target="_blank" rel="external">https://paulswith.github.io/2018/02/24/%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0InceptionV3/</a> 上文记录了如何从一个别人训练好的模型, 切入我们自己的图片, 改为我们自己的模型.<br>本来以为移植到手机很简单, 但是不简单的是我的模型本身就是迁移学习别人的模型,有很多莫名其面的坑,  在CoreML经历了N个坑后,1点14分我搞掂了.</p></blockquote><p><strong> 项目源码和转换源码已经上传到git.</strong><br><a href="https://github.com/Paulswith/machineLearningIntro/tree/master/classification_101" target="_blank" rel="external">https://github.com/Paulswith/machineLearningIntro/tree/master/classification_101</a></p><h3 id="转化为mlmodel"><a href="#转化为mlmodel" class="headerlink" title="转化为mlmodel"></a>转化为mlmodel</h3><p>说说转换为mlmodel的工具有两个:</p><ul><li>coremltools, 它目前只支持五种模型的转换, 不包括tensorflow:<br><img src="/2018/02/25/机器学习迁移模型到IOS/tools.png" alt=""></li><li>若你跟我一样是tensorflow , 那么必须使用tfcoreml<br>  <a href="https://github.com/tf-coreml" target="_blank" rel="external">https://github.com/tf-coreml</a> 有安装方法.<br>  转换Example: <a href="https://github.com/tf-coreml/tf-coreml/tree/master/examples" target="_blank" rel="external">https://github.com/tf-coreml/tf-coreml/tree/master/examples</a> </li></ul><p><strong> 接着往下看: </strong></p><h4 id="是否是graph-pb"><a href="#是否是graph-pb" class="headerlink" title="是否是graph-pb?"></a>是否是graph-pb?</h4><p>如果你跟我一样, 训练的模型, 从tensorflow的代码保存下来的, 调用的:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">saver.save(sess, MODEL_SAVEPATH, global_step=<span class="number">50</span>)</div></pre></td></tr></table></figure></p><p>它并不会保存出一个pb文件, 其中的.meta也需要其他方式转换似乎也可以, 我没有尝试过.<br>用这个方法, 你需要在上方代码的下面加两行,就可以继续:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> i %SAVE_EPOCH == <span class="number">0</span>:</div><div class="line">                    tf.train.write_graph(sess.graph, MODEL_SAVE_DIR, <span class="string">'model.pbtxt'</span>)</div></pre></td></tr></table></figure></p><h4 id="pdtxt固化为pd"><a href="#pdtxt固化为pd" class="headerlink" title="pdtxt固化为pd"></a>pdtxt固化为pd</h4><p>操作参考链接<a href="https://www.jianshu.com/p/091415b114e2" target="_blank" rel="external">https://www.jianshu.com/p/091415b114e2</a><br>我是直接使用的bezel, 编译tensorflow源码后, 直接使用, 其中参数跟着填, 需要注意的是output_node:<br><img src="/2018/02/25/机器学习迁移模型到IOS/guhua.png" alt=""></p><h4 id="导入化图"><a href="#导入化图" class="headerlink" title="导入化图"></a>导入化图</h4><p>导入图和查看图的节点信息:<br> 如果你的图不属于pb文件, 那么就会在导入图的时候报错的.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(TF_MODEL_FILE, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</div><div class="line">    serialized = f.read()</div><div class="line">tf.reset_default_graph()</div><div class="line">original_gdef = tf.GraphDef()</div><div class="line">original_gdef.ParseFromString(serialized)</div><div class="line"></div><div class="line"><span class="comment">##2 可以在这里查看到全部的图信息(前提是你有转换成功)</span></div><div class="line"><span class="keyword">with</span> tf.Graph().as_default() <span class="keyword">as</span> g:</div><div class="line">    tf.import_graph_def(original_gdef, name=<span class="string">''</span>)</div><div class="line">    ops = g.get_operations()</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>):</div><div class="line">            print(<span class="string">'op id &#123;&#125; : op name: &#123;&#125;, op type: "&#123;&#125;"'</span>.format(str(i),ops[i].name, ops[i].type))</div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        print(<span class="string">"全部节点已打印完毕."</span>)</div><div class="line">        <span class="keyword">pass</span></div></pre></td></tr></table></figure></p><h4 id="预处理节点"><a href="#预处理节点" class="headerlink" title="预处理节点"></a>预处理节点</h4><p>其实这一步个人不是很清楚很知道它做了什么,但确是不得不做的. 最后的大小看着也不像是”减包”<br>需要注意两点:</p><ul><li>input_node_names: 这里填写的节点从上方的代码可以打印看得到的, 实际在训练模型的时候, 我们直接喂图片的节点是在”import/DecodeJpeg/contents”, 而这里”必须是import/Mul”.</li><li>output_node_names: 因为模型是剪切拼接的, 这跟tensorflow直接调用是一样的节点.<br><strong> 最后生成一个完整的pb文件. </strong><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">input_node_names = [<span class="string">'import/Mul'</span>, <span class="string">'BottleneckInputPlaceholder'</span>]   <span class="comment"># 本来以为是import/DecodeJpeg/contents, 实际上是Mul(tfcoreml-git上说的)</span></div><div class="line">output_node_names = [<span class="string">'import/pool_3/_reshape'</span>,<span class="string">'final_train_ops/softMax_last'</span>]  <span class="comment"># 想要保存的节点 , 'final_train_ops/softMax_last'</span></div><div class="line"></div><div class="line">gdef = strip_unused_lib.strip_unused(</div><div class="line">        input_graph_def = original_gdef,</div><div class="line">        input_node_names = input_node_names,</div><div class="line">        output_node_names = output_node_names,</div><div class="line">        placeholder_type_enum = dtypes.float32.as_datatype_enum)</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">with</span> gfile.GFile(FROZEN_MODEL_FILE, <span class="string">"wb"</span>) <span class="keyword">as</span> f:</div><div class="line">    f.write(gdef.SerializeToString())</div></pre></td></tr></table></figure></li></ul><h4 id="开始转换"><a href="#开始转换" class="headerlink" title="开始转换"></a>开始转换</h4><ul><li><p>input_tensor_shapes: 是placeholder 和 input节点, 方括号的第一个参数是batch大小,代表一张一张的喂给它. 字典里面这两个, 对应生成后的InceptionV3_input的两个属性.</p></li><li><p>output_tensor_names: 训练后得到的节点, 对应生成后的InceptionV3_output的两个属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">input_tensor_shapes = &#123;</div><div class="line">                        <span class="string">"import/Mul:0"</span>:[<span class="number">1</span>,<span class="number">299</span>,<span class="number">299</span>,<span class="number">3</span>],          <span class="comment"># batch size is 1</span></div><div class="line">                        <span class="string">"BottleneckInputPlaceholder:0"</span>:[<span class="number">1</span>,<span class="number">2048</span>],</div><div class="line">                       &#125;</div><div class="line">output_tensor_names = [<span class="string">'import/pool_3/_reshape:0'</span>,<span class="string">'final_train_ops/softMax_last:0'</span>]</div><div class="line"></div><div class="line"><span class="comment"># Call the converter. This may take a while</span></div><div class="line">coreml_model = tfcoreml.convert(</div><div class="line">        tf_model_path=FROZEN_MODEL_FILE,</div><div class="line">        mlmodel_path=COREML_MODEL_FILE,</div><div class="line">        input_name_shape_dict=input_tensor_shapes,</div><div class="line">        output_feature_names=output_tensor_names,</div><div class="line">        image_input_names = [<span class="string">'import/Mul:0'</span>],</div><div class="line">        red_bias = <span class="number">-1</span>,</div><div class="line">        green_bias = <span class="number">-1</span>,</div><div class="line">        blue_bias = <span class="number">-1</span>,</div><div class="line">        image_scale = <span class="number">2.0</span>/<span class="number">255.0</span>)</div></pre></td></tr></table></figure></li></ul><blockquote><p>上方具体的参数可以在方法看得到,后面四个参数就是我们输入图片时候的均值化,  还有个特殊的参数<code>class_labels</code>, output后的模型可以直接索引到标签, 但是在实践过程中, 我这个本身是迁移别人的学习的模型并起不到作用.</p></blockquote><p>执行完成后生成文件:<br><img src="/2018/02/25/机器学习迁移模型到IOS/model.png" alt=""></p><h3 id="ios-code调用"><a href="#ios-code调用" class="headerlink" title="ios-code调用"></a>ios-code调用</h3><h4 id="了解模型"><a href="#了解模型" class="headerlink" title="了解模型:"></a>了解模型:</h4><p>首先, 直接将inceptionV3.mlmodel拖入到工程:<br>导入头文件, <code>inceptionV3.h</code>, 点开查看:<br><img src="/2018/02/25/机器学习迁移模型到IOS/inout.png" alt=""></p><p>他们之间的关系是, <strong>inception_v3_input导入 -&gt; 启动inception_v3.model训练 -&gt; 得到inception_v3_output</strong> 分别提供了一个实例化方法.</p><h4 id="开始代码"><a href="#开始代码" class="headerlink" title="开始代码"></a>开始代码</h4><p>首先确认他们之间的调用方向 层次, 我直接是参考tensorflow加载的顺序, 只要理解了, 就可以直接调用了:<br>这是Python的调用方法:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">poo3_frist = sess.run(poo3, feed_dict=&#123;inpiut_x: image&#125;)   <span class="comment"># 按照模型的顺序要, 先喂给它图片, 然后图片提取到瓶颈的tensor</span></div><div class="line">result     = sess.run(predict, feed_dict=&#123;change_input:poo3_frist&#125;) <span class="comment"># 瓶颈的tensor再转入input传入, 得到我们最后的predict</span></div></pre></td></tr></table></figure></p><p>如果参照tensorflow加载模型的做法, 我们直接是一张图片, 得到一个run到pool3, 但实际CoreML只给我们生成了一个实例方法:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithBottleneckInputPlaceholder__0:(MLMultiArray *)BottleneckInputPlaceholder__0 import__Mul__0:(CVPixelBufferRef)import__Mul__0;</div></pre></td></tr></table></figure></p><p>方法必须要传入一个<code>MLMultiArray</code>, 而且shape必须一致的. 最后我直接调用<code>MLMultiArray</code>的方法,生成一个0值的2048shape</p><p><strong>预测部分的, 完整核心代码</strong> 均有详细的注释说明<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">- (inception_v3 *)tfModel &#123;</div><div class="line">    <span class="keyword">if</span> (!_tfModel) &#123;</div><div class="line">        <span class="comment">// 1 加载模型, 本身代码会调用init的时候, 方法会调用initWithContentsOfURL, 找到inception文件进行初始化</span></div><div class="line">        _tfModel = [[inception_v3 alloc] init];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> _tfModel;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)predictWithFoodImage:(<span class="built_in">UIImage</span> *)foodImage</div><div class="line">&#123;</div><div class="line">    <span class="comment">// step1: 标准为size, 转为可传入的参数.</span></div><div class="line">    <span class="built_in">UIImage</span> *img = [foodImage scaleToSize:<span class="built_in">CGSizeMake</span>(<span class="number">299</span>, <span class="number">299</span>)];             <span class="comment">// 转换为可传参的图片大小</span></div><div class="line">    CVPixelBufferRef refImage = [[<span class="built_in">UIImage</span> new] pixelBufferFromCGImage:img];  <span class="comment">// 转换为可传参的类型</span></div><div class="line"></div><div class="line">    </div><div class="line">    <span class="comment">// step2.1: 由于一开始是没有BottleneckInputPlaceholder, 直接0值初始一个传入</span></div><div class="line">    MLMultiArray *holder = [[MLMultiArray alloc] initWithShape:@[@<span class="number">2048</span>] dataType:MLMultiArrayDataTypeDouble error:<span class="literal">nil</span>];</div><div class="line">    <span class="comment">// step2.2: 启动预测, 预测完成后得到import__pool_3___reshape__0</span></div><div class="line">    inception_v3Output *output = [<span class="keyword">self</span>.tfModel predictionFromBottleneckInputPlaceholder__0:holder import__Mul__0:refImage error:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="comment">// step3: 从第二步, 完整得到了想要的BottleneckInputPlaceholder, 直接代入, 图片也代入.</span></div><div class="line">    inception_v3Output *output1 = [<span class="keyword">self</span>.tfModel predictionFromBottleneckInputPlaceholder__0:output.import__pool_3___reshape__0 import__Mul__0:refImage error:<span class="literal">nil</span>];</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">// step4: 从final_train_ops__softMax_last__0提取预测结果</span></div><div class="line">    MLMultiArray *__final = output1.final_train_ops__softMax_last__0;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> poAccu:__final];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="调用摄像头进行图片获取"><a href="#调用摄像头进行图片获取" class="headerlink" title="调用摄像头进行图片获取"></a>调用摄像头进行图片获取</h4><p>通过整合代码层次, 代码调用也封装好了, 方便代用:<br> 从简书上拿到别人写好的调用摄像头拍照<a href="https://www.jianshu.com/p/62d69d89fa43" target="_blank" rel="external">https://www.jianshu.com/p/62d69d89fa43</a>, 提取了下代码:<br>主要逻辑:<br>拍照后重置大小展示到view,  异步进行模型预测, 回到主线程展示label结果.<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//触发事件：拍照</span></div><div class="line">- (<span class="keyword">void</span>)addCamera</div><div class="line">&#123;</div><div class="line">    <span class="built_in">UIImagePickerController</span> *picker = [[<span class="built_in">UIImagePickerController</span> alloc] init];</div><div class="line">    picker.delegate = <span class="keyword">self</span>;</div><div class="line">    picker.allowsEditing = <span class="literal">YES</span>; <span class="comment">//可编辑</span></div><div class="line">    <span class="comment">//判断是否可以打开照相机</span></div><div class="line">    <span class="keyword">if</span> ([<span class="built_in">UIImagePickerController</span> isSourceTypeAvailable:<span class="built_in">UIImagePickerControllerSourceTypeCamera</span>]) &#123;</div><div class="line">        <span class="comment">//摄像头</span></div><div class="line">        picker.sourceType = <span class="built_in">UIImagePickerControllerSourceTypeCamera</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//否则打开照片库</span></div><div class="line">        picker.sourceType = <span class="built_in">UIImagePickerControllerSourceTypePhotoLibrary</span>;</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span> presentViewController:picker animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - UIImagePickerControllerDelegate</span></div><div class="line"></div><div class="line"><span class="comment">//拍摄完成后要执行的代理方法</span></div><div class="line">- (<span class="keyword">void</span>)imagePickerController:(<span class="built_in">UIImagePickerController</span> *)picker didFinishPickingMediaWithInfo:(<span class="built_in">NSDictionary</span> *)info</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSString</span> *mediaType = [info objectForKey:<span class="built_in">UIImagePickerControllerMediaType</span>];</div><div class="line">    <span class="keyword">if</span> ([mediaType isEqualToString:<span class="string">@"public.image"</span>]) &#123;</div><div class="line">        <span class="comment">//得到照片</span></div><div class="line">        <span class="built_in">UIImage</span> *image = [info objectForKey:<span class="built_in">UIImagePickerControllerOriginalImage</span>];</div><div class="line">        image = [image scaleToSize:<span class="keyword">self</span>.imageView.frame.size];</div><div class="line">        <span class="keyword">self</span>.imageView.image = image;</div><div class="line">        <span class="comment">// 异步处理, 不要占用主线程:</span></div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_queue_create(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</div><div class="line">            <span class="built_in">NSString</span> *preString = [<span class="keyword">self</span>.prediction predictWithFoodImage:image];</div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                <span class="keyword">self</span>.preLabel.text = preString;</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//进入拍摄页面点击取消按钮</span></div><div class="line">- (<span class="keyword">void</span>)imagePickerControllerDidCancel:(<span class="built_in">UIImagePickerController</span> *)picker</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>制作gif, 直接看图片: 或者上面链接从我的git上下载源码:<br><img src="/2018/02/25/机器学习迁移模型到IOS/1.png?r=20" alt=""><img src="/2018/02/25/机器学习迁移模型到IOS/2.png?r=20" alt=""><img src="/2018/02/25/机器学习迁移模型到IOS/3.png?r=20" alt=""><img src="/2018/02/25/机器学习迁移模型到IOS/4.png?r=20" alt=""></p><p>[<code>好困, 该睡觉了...</code>]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://paulswith.github.io/2018/02/24/%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0InceptionV3/&quot; target=&quot;_blank&quot; rel=&quot;exter
      
    
    </summary>
    
      <category term="MachineLearning" scheme="http://yoursite.com/categories/MachineLearning/"/>
    
    
      <category term="迁移学习移植IOS" scheme="http://yoursite.com/tags/%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E7%A7%BB%E6%A4%8DIOS/"/>
    
  </entry>
  
  <entry>
    <title>迁移学习InceptionV3</title>
    <link href="http://yoursite.com/2018/02/24/%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0InceptionV3/"/>
    <id>http://yoursite.com/2018/02/24/迁移学习InceptionV3/</id>
    <published>2018-02-24T02:37:01.000Z</published>
    <updated>2018-02-24T04:57:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>手动画过AlexNet类似的模型,直接在后面加了一层[,class]的全连接层, 结果预测准确率是90%左右. 当然不是很满意. 于是乎开始各种方法寻求最准的CNN<br>偶然间发现通过迁移学习大赛上高分的作品,进行迁移学习可以让我们拥有更精准的准确率,于是有了本文.<br>总结:: 学会如何迁移优秀的模型来为自己所用!<br><strong> 文章讲述的colab源码已经共享, 请点击下方链接查看即可.</strong><br><a href="https://drive.google.com/file/d/1ahJtJvuHDGh4oS4lyNG0NdtqZuyns4J6/view?usp=sharing" target="_blank" rel="external">https://drive.google.com/file/d/1ahJtJvuHDGh4oS4lyNG0NdtqZuyns4J6/view?usp=sharing</a></p></blockquote><h4 id="迁移准备"><a href="#迁移准备" class="headerlink" title="迁移准备"></a>迁移准备</h4><h5 id="模型选择准备"><a href="#模型选择准备" class="headerlink" title="模型选择准备"></a>模型选择准备</h5><p>首先当然是选择一款高效的模型,查阅了部分资料, 发现googleNet是2014年ILSVRC挑战赛获得冠军, 错误率降低到6.67%, 另一个名字也是InceptionV1, V3就是它优化后的第三代, 错误率更低<br>模型下载:<br><a href="https://storage.googleapis.com/download.tensorflow.org/models/inception_dec_2015.zip" target="_blank" rel="external">https://storage.googleapis.com/download.tensorflow.org/models/inception_dec_2015.zip</a> 并解压得到.pd文件</p><p>执行下方代码, 可以打印出pb文件的全部节点:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">tf_model_path = <span class="string">'/Users/dobby/Desktop/inception_dec_2015/tensorflow_inception_graph.pb'</span></div><div class="line"><span class="keyword">with</span> open(tf_model_path, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</div><div class="line">    serialized = f.read()</div><div class="line">tf.reset_default_graph()</div><div class="line">original_gdef = tf.GraphDef()</div><div class="line">original_gdef.ParseFromString(serialized)</div><div class="line"></div><div class="line"><span class="comment">##2 可以在这里查看到全部的图信息(前提是你有转换成功)</span></div><div class="line"><span class="keyword">with</span> tf.Graph().as_default() <span class="keyword">as</span> g:</div><div class="line">    tf.import_graph_def(original_gdef, name=<span class="string">''</span>)</div><div class="line">    ops = g.get_operations()</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>):</div><div class="line">            print(<span class="string">'op id &#123;&#125; : op name: &#123;&#125;, op type: "&#123;&#125;"'</span>.format(str(i),ops[i].name, ops[i].type))</div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        <span class="keyword">pass</span></div></pre></td></tr></table></figure></p><p>需要关注的输入层:</p><p><img src="/2018/02/24/迁移学习InceptionV3/input.png" alt=""></p><p>和需要被修改最后一层的全连接层:<br><img src="/2018/02/24/迁移学习InceptionV3/fl.png" alt=""></p><p>我们需要接入到这一层, 然后修改后面的node, 修改这一层原本是[2048, 1000] , 现在需要为我们自己的[2048, n_classes] , 我们自己需要分类的大小</p><h5 id="训练环境准备"><a href="#训练环境准备" class="headerlink" title="训练环境准备"></a>训练环境准备</h5><p>训练环境我选择的是colab, google的免费GPU, 部署上传下载到colab可以见:<a href="https://paulswith.github.io/2018/02/01/%E9%83%A8%E7%BD%B2TensorFlow%E5%88%B0Colaboratory/" target="_blank" rel="external">https://paulswith.github.io/2018/02/01/%E9%83%A8%E7%BD%B2TensorFlow%E5%88%B0Colaboratory/</a></p><p>免费的GPU当然很快, 但是坑超巨多, 如何你的VPN不稳定, 就很容易导致断连, 数据模型无法被保存,所以我封装一个小代码块, 在训练区间,保存之后调该方法上传到google-drive:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">colab_to_drive</span><span class="params">(file_path, save_name)</span>:</span></div><div class="line">  <span class="string">'''</span></div><div class="line"><span class="string">   ** 从Colab到drive ** </span></div><div class="line"><span class="string">  '''</span></div><div class="line">  auth.authenticate_user()</div><div class="line">  drive_service = build(<span class="string">'drive'</span>, <span class="string">'v3'</span>)</div><div class="line">  file_metadata = &#123;</div><div class="line">    <span class="string">'name'</span>: save_name,</div><div class="line">    <span class="string">'mimeType'</span>: <span class="string">'text/plain'</span></div><div class="line">  &#125;</div><div class="line">  media = MediaFileUpload(file_path, </div><div class="line">                          mimetype=<span class="string">'text/plain'</span>,</div><div class="line">                          resumable=<span class="keyword">True</span>)</div><div class="line">  drive_service.files().create(body=file_metadata,</div><div class="line">                               media_body=media,</div><div class="line">                               fields=<span class="string">'id'</span>).execute()</div><div class="line">  print(<span class="string">"传输完成."</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload_demol</span><span class="params">()</span>:</span></div><div class="line">  <span class="string">'''</span></div><div class="line"><span class="string">   ** 封装上传 **</span></div><div class="line"><span class="string">  '''</span></div><div class="line">  time_str = datetime.now().strftime(<span class="string">'_%d_%H_%M_%S'</span>)</div><div class="line">  name = <span class="string">'RSM_'</span>+time_str+<span class="string">'.gz'</span></div><div class="line">  tar_cmd = <span class="string">'tar zcvf &#123;a&#125; &#123;b&#125;'</span>.format(a=name, b=MODEL_SAVE_DIR)</div><div class="line">  rm_cmd  = <span class="string">'rm -rf &#123;&#125;'</span>.format(name)</div><div class="line">  get_ipython().system(tar_cmd)</div><div class="line">  colab_to_drive(name, name)</div><div class="line">  get_ipython().system(rm_cmd)</div><div class="line">  print(<span class="string">"上传成功,包名为"</span>,name)</div><div class="line"></div><div class="line"><span class="comment"># upload_demol()</span></div></pre></td></tr></table></figure></p><h4 id="hardCode训练"><a href="#hardCode训练" class="headerlink" title="hardCode训练"></a>hardCode训练</h4><p>当然方法一开始我也是模糊的, 代码参考来自:<br><a href="http://www.cnblogs.com/hellcat/p/6909269.html" target="_blank" rel="external">http://www.cnblogs.com/hellcat/p/6909269.html</a><br>十分感谢前人种树,  方法基本是通用的, 让我学会了如何迁移其他的模型</p><hr><p>但是跑起来是有地方会报错的, 做了修改:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_test_bottlenecks</span><span class="params">(sess,image_lists,n_class,jpeg_data_tensor,bottleneck_tensor)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line"><span class="string">    获取全部的测试数据,计算输出</span></div><div class="line"><span class="string">    :param sess: </span></div><div class="line"><span class="string">    :param image_lists: </span></div><div class="line"><span class="string">    :param n_class: </span></div><div class="line"><span class="string">    :param jpeg_data_tensor: </span></div><div class="line"><span class="string">    :param bottleneck_tensor: </span></div><div class="line"><span class="string">    :return:                   瓶颈输出 &amp; label</span></div><div class="line"><span class="string">    '''</span></div><div class="line">    bottlenecks  = []</div><div class="line">    ground_truths = []</div><div class="line">    label_name_list = list(image_lists.keys())</div><div class="line">    <span class="comment">#  ** 原先方法会报错:</span></div><div class="line">    <span class="comment">#     for label_index,label_name in enumerate(image_lists[label_name_list]):</span></div><div class="line">    <span class="comment">#  **修改如下(3行):</span></div><div class="line">    label_index = random.randrange(n_class)  <span class="comment"># 标签索引随机生成</span></div><div class="line">    label_name = label_name_list[label_index]</div><div class="line">    label_index= label_name_list.index(label_name)</div><div class="line">   category = <span class="string">'testing'</span></div><div class="line">    <span class="keyword">for</span> index, unused_base_name <span class="keyword">in</span> enumerate(image_lists[label_name][category]): <span class="comment"># 索引, &#123;文件名&#125;</span></div><div class="line">        bottleneck = get_or_create_bottleneck(</div><div class="line">            sess, image_lists, label_name, index,</div><div class="line">            category, jpeg_data_tensor, bottleneck_tensor)</div><div class="line">        ground_truth = np.zeros(n_class, dtype=np.float32)</div><div class="line">        ground_truth[label_index] = <span class="number">1.0</span></div><div class="line">        bottlenecks.append(bottleneck)</div><div class="line">        ground_truths.append(ground_truth)</div><div class="line">    <span class="keyword">return</span> bottlenecks, ground_truths</div></pre></td></tr></table></figure></p><h4 id="迁移方法"><a href="#迁移方法" class="headerlink" title="迁移方法"></a>迁移方法</h4><p>几个核心的方法mark下:</p><h5 id="加载获取用得到的tensor"><a href="#加载获取用得到的tensor" class="headerlink" title="加载获取用得到的tensor"></a>加载获取用得到的tensor</h5><p>我们需要获取 图片的输入-&gt; 想断点的这两个节点的tensor<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1. 图加载模型</span></div><div class="line"><span class="keyword">with</span> open(os.path.join(MODEL_DIR, MODEL_FILE), <span class="string">'rb'</span>) <span class="keyword">as</span> f:            </div><div class="line">        graph_def = tf.GraphDef()                                        </div><div class="line">        graph_def.ParseFromString(f.read())                               </div><div class="line">        </div><div class="line"><span class="comment"># 2.导入图, 且从图上读取tensor, return_elements=[BOTTLENECK_TENSOR_NAME,JPEG_DATA_TENSOR_NAME]) 让返回这个tensor</span></div><div class="line"><span class="comment"># 方便我们runsession ,返回后续tensor</span></div><div class="line">bottleneck_tensor,jpeg_data_tensor = tf.import_graph_def(            </div><div class="line">    graph_def,</div><div class="line">    return_elements=[BOTTLENECK_TENSOR_NAME,JPEG_DATA_TENSOR_NAME])</div></pre></td></tr></table></figure></p><h5 id="拿到断点tensor"><a href="#拿到断点tensor" class="headerlink" title="拿到断点tensor"></a>拿到断点tensor</h5><p>上面我们获取到了输入tensor和断点tensor, 操作的步骤如同我们直接调用它的模型是一样的, 按照它们先前的格式将图片输入,然后然后它在我们想要的断点节点返回内容<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_bottleneck_on_images</span><span class="params">(sess,image_data,jpeg_data_tensor,bottleneck_tensor)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line"><span class="string">    使用加载的训练好的Inception-v3模型处理一张图片，得到这个图片的特征向量。</span></div><div class="line"><span class="string">    :param sess:              会话句柄</span></div><div class="line"><span class="string">    :param image_data:        图片文件句柄</span></div><div class="line"><span class="string">    :param jpeg_data_tensor:  输入张量句柄</span></div><div class="line"><span class="string">    :param bottleneck_tensor: 瓶颈张量句柄</span></div><div class="line"><span class="string">    :return:                  瓶颈张量值</span></div><div class="line"><span class="string">    '''</span></div><div class="line">    bottleneck_values = sess.run(bottleneck_tensor,feed_dict=&#123;jpeg_data_tensor:image_data&#125;)</div><div class="line">    print(bottleneck_values.shape) <span class="comment"># 从这里也能知道它返回的shape</span></div><div class="line">    bottleneck_values = np.squeeze(bottleneck_values)</div><div class="line">    <span class="keyword">return</span> bottleneck_values</div></pre></td></tr></table></figure></p><h5 id="定义新网络"><a href="#定义新网络" class="headerlink" title="定义新网络"></a>定义新网络</h5><p>从上面拿到了需要断点的tensor, 它返回shape是[None, 2048], 第一坑placeholder留给它<br>第二个placeholder, 是我们的label, 只需要定义为[None, n_classes]<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">bottleneck_input   = tf.placeholder(tf.float32, [<span class="keyword">None</span>,BOTTLENECK_TENSOR_SIZE], name=<span class="string">'BottleneckInputPlaceholder'</span>)</div><div class="line">ground_truth_input = tf.placeholder(tf.float32, [<span class="keyword">None</span>,n_class], name=<span class="string">'GroundTruthInput'</span>)</div><div class="line"><span class="comment"># 上面的操作后,我们定义好自己的全连接层,接入即可</span></div><div class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">'final_train_ops'</span>):</div><div class="line">    <span class="comment"># Weight-bias初始化</span></div><div class="line">    Weights = tf.Variable(tf.truncated_normal([BOTTLENECK_TENSOR_SIZE,n_class],stddev=<span class="number">0.001</span>)) </div><div class="line">    biases  = tf.Variable(tf.zeros([n_class]))</div><div class="line">    logits  = tf.matmul(bottleneck_input,Weights) + biases</div><div class="line">    final_tensor = tf.nn.softmax(logits, name=<span class="string">'softMax_last'</span>)</div><div class="line">tf.add_to_collection(name=<span class="string">'final_tensor'</span>, value=final_tensor)</div></pre></td></tr></table></figure></p><h5 id="定义常规的优化器"><a href="#定义常规的优化器" class="headerlink" title="定义常规的优化器"></a>定义常规的优化器</h5><p>这一步都是通用的, pass哈<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cross_entropy = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits_v2(logits=logits,labels=ground_truth_input))</div><div class="line">train_step    = tf.train.RMSPropOptimizer(LEARNING_RATE).minimize(cross_entropy)</div><div class="line"><span class="comment"># 正确率</span></div><div class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">'evaluation'</span>):</div><div class="line">    correct_prediction = tf.equal(tf.argmax(final_tensor,<span class="number">1</span>,name=<span class="string">'argmax_softMax_last'</span>),tf.argmax(ground_truth_input,<span class="number">1</span>))</div><div class="line">    evaluation_step    = tf.reduce_mean(tf.cast(correct_prediction,tf.float32))</div></pre></td></tr></table></figure></p><h4 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h4><h5 id="batchSize"><a href="#batchSize" class="headerlink" title="batchSize"></a>batchSize</h5><p>我做的是101分类, batchSize对于梯队下降是起到很重要的作用的, 但对于定义多少却是个难题(因为之前都是10分类大小的, 大多定义batchSize=30太随意), 为什么这么关注:<br><strong>batch数太小，而类别又比较多的时候，真的可能会导致loss函数震荡而不收敛，尤其是在你的网络比较复杂的时候</strong><br><strong>batch太大, 导致内存利用紧张</strong><br>最后解决方法, 参考文章:<br><a href="https://www.zhihu.com/question/32673260" target="_blank" rel="external">https://www.zhihu.com/question/32673260</a><br>最后选择的是batchSize = 101</p><h5 id="国外网络不稳定-导致容易掉线"><a href="#国外网络不稳定-导致容易掉线" class="headerlink" title="国外网络不稳定,导致容易掉线"></a>国外网络不稳定,导致容易掉线</h5><p>因为colab是需要墙外访问, 当网络不稳定断开的时候, 我们重新进入环境就必须重启它, 导致跑着的变量代码必须重新启动. 这是很难办.最好用两个方法解决:<br>1, 让数据接着跑:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">            sess.run(tf.global_variables_initializer())</div><div class="line">            saver = tf.train.Saver()</div><div class="line">            <span class="keyword">if</span> keepon:</div><div class="line">                print(<span class="string">'继续加载模型:'</span>)</div><div class="line">                saver.restore(sess, tf.train.latest_checkpoint(MODEL_SAVE_DIR))</div></pre></td></tr></table></figure></p><blockquote><p>good job</p></blockquote><p>2, 善于保存,善于上传到driver<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> i % <span class="number">1000</span> == <span class="number">0</span>:</div><div class="line">                    print(<span class="string">"进行存储上传"</span>)</div><div class="line">                    tf.train.write_graph(sess.graph, MODEL_SAVE_DIR, <span class="string">'model.pbtxt'</span>)</div><div class="line">                    upload_demol()</div><div class="line">                saver.save(sess, MODEL_SAVEPATH, global_step=<span class="number">50</span>) <span class="comment"># 50次保存一次</span></div></pre></td></tr></table></figure></p><h5 id="优化器的坑"><a href="#优化器的坑" class="headerlink" title="优化器的坑"></a>优化器的坑</h5><p>如果你查看了上面blog的作者, 他使用的:<code>GradientDescentOptimizer</code>, 跑了几万次迭代后, 容易陷入局部参数. 当然也有进行过, placeHolder-LR, 但是情况还不是很乐观, 可能GSD确实不适合我.<br>你可以看到我最后选择的<code>RMSPropOptimizer</code>, 这是一类自适应学习率, 参考文章:<br><a href="http://ycszen.github.io/2016/08/24/SGD%EF%BC%8CAdagrad%EF%BC%8CAdadelta%EF%BC%8CAdam%E7%AD%89%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E5%92%8C%E6%AF%94%E8%BE%83/" target="_blank" rel="external">http://ycszen.github.io/2016/08/24/SGD%EF%BC%8CAdagrad%EF%BC%8CAdadelta%EF%BC%8CAdam%E7%AD%89%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E5%92%8C%E6%AF%94%E8%BE%83/</a></p><p>替换为RMS后的效果很是不错(之所以有部分高震荡, 是因为断网重连后, 它还没适应下去,所以loss依然很高, 正常现象除非你网络稳定,loss也会很好看~)<br><img src="/2018/02/24/迁移学习InceptionV3/loss.png" alt=""></p><h4 id="加载模型识别"><a href="#加载模型识别" class="headerlink" title="加载模型识别"></a>加载模型识别</h4><p>识别率基本是满足的了, 达到了95%以上, 下一步是迁移到IOS的APP上, 拿张图片show一下看准不准:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line">__author = <span class="string">''</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># ***********************define***********************</span></div><div class="line">MODEL_PATH   = <span class="string">'/Users/dobby/TEMP/SaveData/model/101_class_model.ckpt-50.meta'</span></div><div class="line">MODEL_DIR    =  <span class="string">'/Users/dobby/TEMP/SaveData/model'</span></div><div class="line">image_path   = <span class="string">'/Users/dobby/Desktop/pisa.jpeg'</span></div><div class="line">CATO_PATH    = <span class="string">'/Users/dobby/TEMP/SaveData/model/catogory.info'</span></div><div class="line">catogo_list  = open(CATO_PATH, <span class="string">'r'</span>).read().split(<span class="string">'|'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># ***********************LOADGraph***********************</span></div><div class="line">sess = tf.Session()</div><div class="line">saver = tf.train.import_meta_graph(MODEL_PATH)</div><div class="line">saver.restore(sess, tf.train.latest_checkpoint(MODEL_DIR))</div><div class="line">graph = tf.get_default_graph()</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># ***********************Define-Node***********************</span></div><div class="line">inpiut_x     = graph.get_tensor_by_name(<span class="string">'import/DecodeJpeg/contents:0'</span>)</div><div class="line">poo3         = graph.get_tensor_by_name(<span class="string">'import/pool_3/_reshape:0'</span>)</div><div class="line">change_input = graph.get_tensor_by_name(<span class="string">'BottleneckInputPlaceholder:0'</span>)</div><div class="line">predict      = graph.get_tensor_by_name(<span class="string">'final_train_ops/softMax_last:0'</span>)</div><div class="line"></div><div class="line">print(<span class="string">'加载模型成功'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">classification_photo</span><span class="params">()</span>:</span></div><div class="line">    <span class="comment"># step 打开图片切换格式</span></div><div class="line"></div><div class="line">    image = tf.gfile.FastGFile(image_path, <span class="string">'rb'</span>).read()        <span class="comment"># inceptionV3不需要转换图片, 它自己换处理图片</span></div><div class="line">    poo3_frist = sess.run(poo3, feed_dict=&#123;inpiut_x: image&#125;)   <span class="comment"># 按照模型的顺序要, 先喂给它图片, 然后图片提取到瓶颈的tensor</span></div><div class="line">    result = sess.run(predict, feed_dict=&#123;change_input:poo3_frist&#125;) <span class="comment"># 瓶颈的tensor再转入input传入, 得到我们最后的predict</span></div><div class="line">    ar = np.array(result).flatten().tolist()</div><div class="line">    inde = ar.index(max(ar))</div><div class="line">    print(<span class="string">"it's a &#123;&#125; photo"</span>.format(catogo_list[inde]))</div><div class="line"></div><div class="line">classification_photo()</div></pre></td></tr></table></figure></p><p><img src="/2018/02/24/迁移学习InceptionV3/succeed.png" alt=""></p><h4 id="预告"><a href="#预告" class="headerlink" title="预告"></a>预告</h4><p>将训练好的模型移动到移动端, 基本已经完成,期待更新吧.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;手动画过AlexNet类似的模型,直接在后面加了一层[,class]的全连接层, 结果预测准确率是90%左右. 当然不是很满意. 于是乎开始各种方法寻求最准的CNN&lt;br&gt;偶然间发现通过迁移学习大赛上高分的作品,进行迁移学习可以让我们拥有更精准的准
      
    
    </summary>
    
      <category term="MachineLearning" scheme="http://yoursite.com/categories/MachineLearning/"/>
    
    
      <category term="迁移学习" scheme="http://yoursite.com/tags/%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>部署TensorFlow到Colaboratory</title>
    <link href="http://yoursite.com/2018/02/01/%E9%83%A8%E7%BD%B2TensorFlow%E5%88%B0Colaboratory/"/>
    <id>http://yoursite.com/2018/02/01/部署TensorFlow到Colaboratory/</id>
    <published>2018-02-01T06:48:23.000Z</published>
    <updated>2018-02-01T09:24:18.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个二分类的机器学习, 用TensorFlow写的, 刚好看到google提供的免费褥羊毛GPU, 虽然坑很多, 但还是部署上去了,GPU效率真的比CPU强的多多.<br><a href="https://colab.research.google.com/notebook#fileId=/v2/external/notebooks/io.ipynb&amp;scrollTo=sOm9PFrT8mGG" target="_blank" rel="external">官方完整的帮助连接</a>在这里,注意上面的代码是基于Python2的, 我用的python3</p></blockquote><h3 id="数据集准备"><a href="#数据集准备" class="headerlink" title="数据集准备"></a>数据集准备</h3><h4 id="CSV之类的轻量数据集"><a href="#CSV之类的轻量数据集" class="headerlink" title="CSV之类的轻量数据集"></a>CSV之类的轻量数据集</h4><p>PASS, 有即可</p><h4 id="TFRecord重量数据集"><a href="#TFRecord重量数据集" class="headerlink" title="TFRecord重量数据集"></a>TFRecord重量数据集</h4><p>可以类似我这样子, 将数据存储到目录下<code>Datasets</code>下, 推荐tar压缩<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar zcvf Datasets.gz Datasets</div></pre></td></tr></table></figure></p><p>自行配置好谷歌Drive, 链接<a href="https://www.google.com/drive/" target="_blank" rel="external">https://www.google.com/drive/</a><br>下载符合电脑版本, 把数据集存入同步到云端.</p><h3 id="如何上传"><a href="#如何上传" class="headerlink" title="如何上传"></a>如何上传</h3><p>打开你的Colaboratory-new一个jupyter脚本.</p><h4 id="小文件上传"><a href="#小文件上传" class="headerlink" title="小文件上传"></a>小文件上传</h4><p><em>for Python2:</em><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> google.colab <span class="keyword">import</span> files</div><div class="line"></div><div class="line"><span class="comment"># 你需填的:</span></div><div class="line">FILE_NAME = <span class="string">'想保存到Colaboratory的文件名'</span></div><div class="line"></div><div class="line">uploaded = files.upload()</div><div class="line"><span class="keyword">with</span> open(FILE_NAME, <span class="string">'wb'</span>) <span class="keyword">as</span> file:</div><div class="line">    file.write(uploaded[uploaded.keys()[<span class="number">0</span>]])</div></pre></td></tr></table></figure></p><p><em>but for Python3:</em><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> google.colab <span class="keyword">import</span> files</div><div class="line"></div><div class="line"><span class="comment"># 你需填的:</span></div><div class="line">FILE_NAME = <span class="string">'想保存到Colaboratory的文件名'</span></div><div class="line"></div><div class="line">uploaded = files.upload()</div><div class="line"><span class="keyword">with</span> open(FILE_NAME, <span class="string">'wb'</span>) <span class="keyword">as</span> file:</div><div class="line">    file.write(uploaded[list[uploaded.keys()][<span class="number">0</span>]])</div></pre></td></tr></table></figure></p><blockquote><p>对应的python执行上述代码后, 会出现<code>Choose file</code>按钮, 选择本地文件确认即可上传, 默认在当前路径, 可用<code>!ls -l</code>查看下</p></blockquote><h4 id="大文件上传"><a href="#大文件上传" class="headerlink" title="大文件上传"></a>大文件上传</h4><p><em>下面开始我就没有试过python2了,都是基于python3</em></p><p>如果是大文件上传, 就按照前面的准备, 我们已经把文件传到了GoogleDrive云盘.<br>Now, 在浏览器打开Drive找到那个文件, 右键-&gt;查看共享链接: -&gt; 拷贝id=后面这个key, 粘贴到下方代码的位置<br><img src="/2018/02/01/部署TensorFlow到Colaboratory/shareLinke.png" alt=""><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 这行代码相当于unix,会去帮我们安装这个包</span></div><div class="line">!pip install -U -q PyDrive</div><div class="line"></div><div class="line"><span class="keyword">from</span> pydrive.auth <span class="keyword">import</span> GoogleAuth</div><div class="line"><span class="keyword">from</span> pydrive.drive <span class="keyword">import</span> GoogleDrive</div><div class="line"><span class="keyword">from</span> google.colab <span class="keyword">import</span> auth</div><div class="line"><span class="keyword">from</span> oauth2client.client <span class="keyword">import</span> GoogleCredentials</div><div class="line"></div><div class="line"><span class="comment"># 你需填的:</span></div><div class="line">PACKAGE_ID = <span class="string">'key粘贴到这里'</span></div><div class="line">PACKAGE_NAME = <span class="string">'drive文件的名字还是Colaboratory将存储的名字呢,你自己试试, 我就是填drive对应的名字'</span></div><div class="line"></div><div class="line"></div><div class="line">auth.authenticate_user()</div><div class="line">gauth = GoogleAuth()</div><div class="line">gauth.credentials = GoogleCredentials.get_application_default()</div><div class="line">drive = GoogleDrive(gauth)</div><div class="line"></div><div class="line">downloaded = drive.CreateFile(&#123;<span class="string">'id'</span>:PACKAGE_ID&#125;)</div><div class="line">downloaded.GetContentFile(PACKAGE_NAME)</div><div class="line">print(<span class="string">'Transpose succeed.'</span>)</div></pre></td></tr></table></figure></p><blockquote><p>执行上述代码, 会弹出一个授权链接和一个授权码输入框, 授权链接授权后会给你这串授权码,粘贴回车即可.依然可以用<code>!ls -l</code>查看下, <code>Colaboratory</code>有自带一些命令的, 在/bin下, 所以可以用tar命令进行解压:<code>tar czvf Datasets.gz</code></p></blockquote><h3 id="训练后的内容数据如何下载"><a href="#训练后的内容数据如何下载" class="headerlink" title="训练后的内容数据如何下载"></a>训练后的内容数据如何下载</h3><p>训练后的模型-tensorBoardLog等文件我们会把它下载下来, 以便我们后续使用. so, 这里来记录下如何下载下来</p><h4 id="小文件"><a href="#小文件" class="headerlink" title="小文件"></a>小文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> google.colab <span class="keyword">import</span> files</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 你需要填的:</span></div><div class="line">FILE_PATH = <span class="string">'下载的文件路径'</span></div><div class="line"></div><div class="line">files.download(FILE_PATH)</div></pre></td></tr></table></figure><blockquote><p><em>尴尬脸</em> 简单吧,简单到写不下去了</p></blockquote><h4 id="大文件"><a href="#大文件" class="headerlink" title="大文件"></a>大文件</h4><p>大文件还是推荐打包, tar:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> google.colab <span class="keyword">import</span> auth</div><div class="line"><span class="keyword">from</span> googleapiclient.discovery <span class="keyword">import</span> build</div><div class="line"><span class="keyword">from</span> googleapiclient.http <span class="keyword">import</span> MediaFileUpload</div><div class="line"></div><div class="line"><span class="comment"># 你需要填的:</span></div><div class="line">SAVE_INTODRIVE_NAME = <span class="string">'想以什么名字保存到drive'</span></div><div class="line">FILE_PATH = <span class="string">'想下载的文件路径'</span></div><div class="line"></div><div class="line">auth.authenticate_user()</div><div class="line">drive_service = build(<span class="string">'drive'</span>, <span class="string">'v3'</span>)</div><div class="line">file_metadata = &#123;</div><div class="line">  <span class="string">'name'</span>:SAVE_INTODRIVE_NAME,</div><div class="line">  <span class="string">'mimeType'</span>: <span class="string">'text/plain'</span></div><div class="line">&#125;</div><div class="line">media = MediaFileUpload(FILE_PATH, </div><div class="line">                        mimetype=<span class="string">'text/plain'</span>,</div><div class="line">                        resumable=<span class="keyword">True</span>)</div><div class="line">created = drive_service.files().create(body=file_metadata,</div><div class="line">                                       media_body=media,</div><div class="line">                                       fields=<span class="string">'id'</span>).execute()</div><div class="line">print(<span class="string">'File ID: &#123;&#125;'</span>.format(created.get(<span class="string">'id'</span>)))</div><div class="line">print(<span class="string">'Transpose succeed.'</span>)</div></pre></td></tr></table></figure></p><h3 id="封装起来就轻松很多了"><a href="#封装起来就轻松很多了" class="headerlink" title="封装起来就轻松很多了"></a>封装起来就轻松很多了</h3><p>这是简单封装起来, 输入对应参数就直接使用了:<br>连接: <a href="https://drive.google.com/file/d/1L7exa7j9ALc7J_PolwzNO3PlZDBmp4C-/view?usp=sharing" target="_blank" rel="external">https://drive.google.com/file/d/1L7exa7j9ALc7J_PolwzNO3PlZDBmp4C-/view?usp=sharing</a><br><img src="/2018/02/01/部署TensorFlow到Colaboratory/pack.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一个二分类的机器学习, 用TensorFlow写的, 刚好看到google提供的免费褥羊毛GPU, 虽然坑很多, 但还是部署上去了,GPU效率真的比CPU强的多多.&lt;br&gt;&lt;a href=&quot;https://colab.research.google
      
    
    </summary>
    
      <category term="MachineLearning" scheme="http://yoursite.com/categories/MachineLearning/"/>
    
    
      <category term="Colaboratory" scheme="http://yoursite.com/tags/Colaboratory/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow数据集制作实战</title>
    <link href="http://yoursite.com/2018/01/20/TensorFlow%E6%95%B0%E6%8D%AE%E9%9B%86%E5%88%B6%E4%BD%9C%E5%AE%9E%E6%88%98/"/>
    <id>http://yoursite.com/2018/01/20/TensorFlow数据集制作实战/</id>
    <published>2018-01-20T07:52:53.000Z</published>
    <updated>2018-01-20T09:36:19.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是实战篇,往下看先</p></blockquote><h4 id="当前数据"><a href="#当前数据" class="headerlink" title="当前数据"></a>当前数据</h4><p><img src="/2018/01/20/TensorFlow数据集制作实战/all_data.png" alt=""><br>当前我有这些图片数据, 分为是飞机(plane_)和不是飞机(plane_false)的二分类数据集原图.分别存在两个不同的文件夹</p><ul><li>数据1 -&gt; 大概是1600+张</li><li>数据0 -&gt; 大概是160+张</li></ul><p>比例是10:1左右, 而数量1800+上来看也不是很理想,  我这里为了省事是直接水平翻转图片, 得到1800*2(待会见代码). 当然为了避免欠拟合情况当然更好的方法是挖掘更多的资源.  </p><h4 id="根据文件夹标签化图片"><a href="#根据文件夹标签化图片" class="headerlink" title="根据文件夹标签化图片"></a>根据文件夹标签化图片</h4><p>头部一些声明:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line">__author = <span class="string">'dobby'</span></div><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</div><div class="line"></div><div class="line"></div><div class="line">plane_path = <span class="string">'/Users/dobby/Documents/data_img/plane'</span></div><div class="line">UNplane_path = <span class="string">'/Users/dobby/Documents/data_img/UNplane'</span></div><div class="line">records_path = <span class="string">'/Users/dobby/Documents/data_img/train.tfrecords'</span></div><div class="line">dataset_list = []</div></pre></td></tr></table></figure></p><p>遍历这两个文件夹, 如果是plane文件夹,那里面存储是label=1的图片, 反之是0. 进行标签化<br>存储方式为(image_path, label)的元组 一起存储在dataset_list数组中<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">classic_data</span><span class="params">(path)</span>:</span></div><div class="line">    <span class="comment"># 根据目录标签数据</span></div><div class="line">    <span class="keyword">if</span> path == plane_path:</div><div class="line">        label = <span class="number">1</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        label = <span class="number">0</span></div><div class="line">    </div><div class="line">    file_list =  os.listdir(path)</div><div class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> file_list:</div><div class="line">        <span class="keyword">if</span> each[:<span class="number">5</span>] != <span class="string">'plane'</span>:</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        im_full_path = os.path.join(path, each)</div><div class="line">        dataset_list.append((im_full_path, label))</div></pre></td></tr></table></figure></p><h4 id="转为数据集"><a href="#转为数据集" class="headerlink" title="转为数据集"></a>转为数据集</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_record</span><span class="params">(data_list, should_transpose=False)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">     图片转为bytes写入</span></div><div class="line"><span class="string">     字符串也是bytes</span></div><div class="line"><span class="string">     1/0 Int</span></div><div class="line"><span class="string">    """</span></div><div class="line">    counter = <span class="number">0</span></div><div class="line">     <span class="comment"># 新建一个写入session</span></div><div class="line">    writer = tf.python_io.TFRecordWriter(records_path)</div><div class="line">    <span class="keyword">for</span> path,label <span class="keyword">in</span> data_list:</div><div class="line">        counter += <span class="number">1</span></div><div class="line">        print(<span class="string">"&#123;i&#125;,&#123;j&#125;\n"</span>.format(i=path, j=label))</div><div class="line">        <span class="comment"># 打开图片</span></div><div class="line">        img = Image.open(path)</div><div class="line">        <span class="comment"># 将图片统一大小</span></div><div class="line">        img = img.resize((<span class="number">300</span>, <span class="number">300</span>))</div><div class="line">        <span class="comment"># 转换为bytes</span></div><div class="line">        img_raw = img.tobytes()</div><div class="line">        data = tf.train.Example(</div><div class="line">            features=tf.train.Features(</div><div class="line">                feature=&#123;</div><div class="line">                    <span class="string">'label'</span>:tf.train.Feature(int64_list=tf.train.Int64List(value=[label])), <span class="comment"># 0/1 分类,所以是INT</span></div><div class="line">                    <span class="string">'image'</span>:tf.train.Feature(bytes_list=tf.train.BytesList(value=[img_raw])) <span class="comment"># 字符串/图片/语音用bytes</span></div><div class="line">                &#125;</div><div class="line">            )</div><div class="line">        )</div><div class="line">        writer.write(data.SerializeToString())</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> should_transpose:</div><div class="line">            counter += <span class="number">1</span></div><div class="line">            <span class="comment"># 将图片左右翻转后生成一张新的图片,label不变,</span></div><div class="line">            rot_img = img.transpose(Image.FLIP_LEFT_RIGHT)</div><div class="line">            rot_img_raw = rot_img.tobytes()</div><div class="line">            data_2 = tf.train.Example(</div><div class="line">                features=tf.train.Features(</div><div class="line">                    feature=&#123;</div><div class="line">                        <span class="string">'label'</span>:tf.train.Feature(int64_list=tf.train.Int64List(value=[label])),</div><div class="line">                        <span class="string">'image'</span>:tf.train.Feature(bytes_list=tf.train.BytesList(value=[rot_img_raw]))</div><div class="line">                    &#125;</div><div class="line">                )</div><div class="line">            )</div><div class="line"></div><div class="line">            writer.write(data_2.SerializeToString())</div><div class="line">    writer.close()</div><div class="line">    print(<span class="string">"写入数据集-DONE, 共存&#123;&#125;个数据"</span>.format(counter))</div></pre></td></tr></table></figure><ul><li><code>writer = tf.python_io.TFRecordWriter(records_path)</code>启动一个写入TFRecord句柄, 遍历数组取出图片和label, 将图片设置统一大小并转为bytes.</li><li><code>tf.train.Example(tf.train.Features)</code>是核心的处理代码, Example成TensorFlow的特定规则数据, 通过使用TFRecordWriter写入到TFRecord中.Example包含一个键值对数据结构(与dict相同), 使用属性features记录, 因此, 初始化时必须传入这个features参数</li><li><code>writer.write(data.SerializeToString())</code>把Example序列成字符串写入TFRecord</li><li><code>should_transpose=False</code>参数用来配置是否水平翻转图片, 并令数据扩大一倍</li><li>当然关于TFRecord的写入具体规则, 如果需要可以参考该链接<a href="http://blog.csdn.net/qq_39037910/article/details/72900308" target="_blank" rel="external">Tensorflow: 文件读写</a></li></ul><h4 id="测试是否写入成功"><a href="#测试是否写入成功" class="headerlink" title="测试是否写入成功"></a>测试是否写入成功</h4><p>执行函数代码, 需要注意, 我提前将数据存储在python的列表中的, 可以使用<code>random.shuffle</code>进行数据的洗牌<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">classic_data(plane_path)</div><div class="line">classic_data(UNplane_path)</div><div class="line">random.shuffle(dataset_list)</div><div class="line">create_record(dataset_list, should_transpose=<span class="keyword">True</span>)</div></pre></td></tr></table></figure></p><p>结果:<br><img src="/2018/01/20/TensorFlow数据集制作实战/succeed.png" alt=""></p><p>可以看到数据洗牌, 而且数据*2, 都成功做到了.<br><img src="/2018/01/20/TensorFlow数据集制作实战/tu.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这是实战篇,往下看先&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;当前数据&quot;&gt;&lt;a href=&quot;#当前数据&quot; class=&quot;headerlink&quot; title=&quot;当前数据&quot;&gt;&lt;/a&gt;当前数据&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/2018/0
      
    
    </summary>
    
      <category term="MachineLearning" scheme="http://yoursite.com/categories/MachineLearning/"/>
    
    
      <category term="TensorFlow" scheme="http://yoursite.com/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow数据集-Dataset-API</title>
    <link href="http://yoursite.com/2018/01/20/TensorFlow%E6%95%B0%E6%8D%AE%E9%9B%86-Dataset-API/"/>
    <id>http://yoursite.com/2018/01/20/TensorFlow数据集-Dataset-API/</id>
    <published>2018-01-20T06:52:53.000Z</published>
    <updated>2018-01-20T07:50:41.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>TensorFlow在学习的时候, 它是有一个mnist数据集让我们学习的. 通过batch_size来每轮数据训练的大小, 现在打算将一个我们实际的数据转换为跟mnist数据集一样的效果</p></blockquote><h4 id="内存中自定义数据"><a href="#内存中自定义数据" class="headerlink" title="内存中自定义数据"></a>内存中自定义数据</h4><blockquote><p> Dataset-API是1.3版引入的, 支持从内存中/硬盘中生成数据集.</p></blockquote><ul><li><p>一维数组<br>直接就是给到一维数组, 生成数据集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dataset = tf.data.Dataset.from_tensor_slices(np.array([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>]))</div><div class="line">out_put=<span class="string">""""</span></div><div class="line"><span class="string">1.0</span></div><div class="line"><span class="string">2.0</span></div><div class="line"><span class="string">3.0</span></div><div class="line"><span class="string">4.0</span></div><div class="line"><span class="string">5.0</span></div><div class="line"><span class="string">"""</span></div></pre></td></tr></table></figure></li><li><p>多维数组, size=(5,2) , 可以理解为(count, dimension)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dataset = tf.data.Dataset.from_tensor_slices(np.random.uniform(size=(<span class="number">5</span>, <span class="number">2</span>)))</div><div class="line">out_put=<span class="string">"""</span></div><div class="line"><span class="string">[ 0.01721917  0.4621821 ]</span></div><div class="line"><span class="string">[ 0.58484623  0.13534625]</span></div><div class="line"><span class="string">[ 0.83591111  0.01397783]</span></div><div class="line"><span class="string">[ 0.88934806  0.97464257]</span></div><div class="line"><span class="string">[ 0.76707649  0.42036516]</span></div><div class="line"><span class="string">"""</span></div></pre></td></tr></table></figure></li><li><p>元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">dataset = tf.data.Dataset.from_tensor_slices(</div><div class="line">  (np.array([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>]), np.random.uniform(size=(<span class="number">5</span>, <span class="number">2</span>)))</div><div class="line">)</div><div class="line">out_put=<span class="string">"""</span></div><div class="line"><span class="string">元组的形式:</span></div><div class="line"><span class="string">(1.0, array([ 0.41459922,  0.75492457]))</span></div><div class="line"><span class="string">(2.0, array([ 0.47954237,  0.93916116]))</span></div><div class="line"><span class="string">(3.0, array([ 0.70576017,  0.58064858]))</span></div><div class="line"><span class="string">(4.0, array([ 0.8239234 ,  0.92814029]))</span></div><div class="line"><span class="string">(5.0, array([ 0.03073594,  0.16718188]))</span></div><div class="line"><span class="string">"""</span></div></pre></td></tr></table></figure></li><li><p>字典<br>字典的格式给到,结果也是字典, 按照key索引(<strong>这种用的比较多一些</strong>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">dataset = tf.data.Dataset.from_tensor_slices(</div><div class="line">    &#123;</div><div class="line">        <span class="string">"a"</span>: np.array([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>]),</div><div class="line">        <span class="string">"b"</span>: np.random.uniform(size=(<span class="number">5</span>, <span class="number">2</span>))</div><div class="line">    &#125;</div><div class="line">)</div><div class="line">out_put=<span class="string">"""</span></div><div class="line"><span class="string">字典的形式:</span></div><div class="line"><span class="string">&#123;'a': 1.0, 'b': array([ 0.15337225,  0.97730736])&#125;</span></div><div class="line"><span class="string">&#123;'a': 2.0, 'b': array([ 0.89860896,  0.95473649])&#125;</span></div><div class="line"><span class="string">&#123;'a': 3.0, 'b': array([ 0.79198725,  0.84507321])&#125;</span></div><div class="line"><span class="string">&#123;'a': 4.0, 'b': array([ 0.27289686,  0.56223038])&#125;</span></div><div class="line"><span class="string">&#123;'a': 5.0, 'b': array([ 0.19825011,  0.44183586])&#125;</span></div><div class="line"><span class="string">"""</span></div></pre></td></tr></table></figure></li></ul><h4 id="两种输出验证方式"><a href="#两种输出验证方式" class="headerlink" title="两种输出验证方式"></a>两种输出验证方式</h4><blockquote><p>当内存中数据生成后, 我们通过这两种方式来验证下<br><code>dataset</code>来自上方代码</p></blockquote><ul><li><p>index提取(缺点是需要提前知道个数)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iterator = dataset.make_one_shot_iterator()</div><div class="line">one_element = iterator.get_next()</div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">         print(sess.run(one_element))</div></pre></td></tr></table></figure></li><li><p>死循环提取, 当超过个数的时候会抛出OutOfRangeError,以此停止(<strong>因此它适合全部的场合</strong>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">iterator = dataset.make_one_shot_iterator()</div><div class="line">one_element = iterator.get_next()</div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            print(sess.run(one_element))</div><div class="line">    <span class="keyword">except</span> tf.errors.OutOfRangeError:</div><div class="line">        print(<span class="string">"end!"</span>)</div></pre></td></tr></table></figure></li></ul><h4 id="数据混淆预处理"><a href="#数据混淆预处理" class="headerlink" title="数据混淆预处理"></a>数据混淆预处理</h4><blockquote><p>当数据从数据集读取的时候,可能存在一些不合理性,我们需要进行混淆. 又或者你的数据不是很足够, 类似图片左右投影一般进行N*2复制来扩大数据集. 诸如此类的预处理是很有必要的.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dataset = tf.data.Dataset.from_tensor_slices(np.array([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>]))</div></pre></td></tr></table></figure><ul><li><p>dataset.map(func), 可以理解一个很酷的装饰器,如例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dataset = dataset.map(<span class="keyword">lambda</span> x: x + <span class="number">1</span>)</div><div class="line">out_put=<span class="string">"""</span></div><div class="line"><span class="string">2.0, 3.0, 4.0, 5.0, 6.0</span></div><div class="line"><span class="string">"""</span></div></pre></td></tr></table></figure></li><li><p>dataset = dataset.batch(batch_size), 可以按batch_size格式, 无法放大</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ataset = dataset.batch(<span class="number">2</span>)</div><div class="line">out_put=<span class="string">"""</span></div><div class="line"><span class="string"># 注意上方batch原先是5的, 现在传入2之后最大只有2. </span></div><div class="line"><span class="string">2,</span></div><div class="line"><span class="string">2,</span></div><div class="line"><span class="string">1</span></div><div class="line"><span class="string">"""</span></div></pre></td></tr></table></figure></li><li><p>dataset.shuffle(buffer_size) , 按照大小进行打乱,特别注意buffer最好大于数据的数量, 详见<a href="https://stackoverflow.com/questions/46444018/meaning-of-buffer-size-in-dataset-map-dataset-prefetch-and-dataset-shuffle" target="_blank" rel="external">stackoverflow</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dataset = dataset.shuffle(buffer_size=<span class="number">5</span>)</div><div class="line">out_put=<span class="string">"""</span></div><div class="line"><span class="string">3.0</span></div><div class="line"><span class="string">1.0</span></div><div class="line"><span class="string">2.0</span></div><div class="line"><span class="string">5.0</span></div><div class="line"><span class="string">4.0</span></div><div class="line"><span class="string">"""</span></div></pre></td></tr></table></figure></li><li><p>dataset.repeat(repeat_count) 数据重复放大repeat_count倍, 搭配shuffle打乱更酷(数据总数*repeat_count,这样子才足以覆盖全部数据), repeat必须带有参数, 不然会无限重复下去</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dataset = dataset.repeat(<span class="number">10</span>).shuffle(buffer_size=<span class="number">1000</span>*<span class="number">10</span>)</div><div class="line"><span class="comment"># 数量太多不贴了</span></div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;TensorFlow在学习的时候, 它是有一个mnist数据集让我们学习的. 通过batch_size来每轮数据训练的大小, 现在打算将一个我们实际的数据转换为跟mnist数据集一样的效果&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;内存中
      
    
    </summary>
    
      <category term="MachineLearning" scheme="http://yoursite.com/categories/MachineLearning/"/>
    
    
      <category term="TensorFlow" scheme="http://yoursite.com/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>wda玩微信跳一跳</title>
    <link href="http://yoursite.com/2017/12/30/wda%E7%8E%A9%E5%BE%AE%E4%BF%A1%E8%B7%B3%E4%B8%80%E8%B7%B3/"/>
    <id>http://yoursite.com/2017/12/30/wda玩微信跳一跳/</id>
    <published>2017-12-30T05:20:31.000Z</published>
    <updated>2017-12-30T07:30:10.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>… 等我写完这个脚本,刷到了372分, 才发现Android的大佬们早就有一套操作了, 似乎想法都差不多,我的环境是在ios-mac上执行</p></blockquote><h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><h4 id="WebDriverAgent"><a href="#WebDriverAgent" class="headerlink" title="WebDriverAgent"></a>WebDriverAgent</h4><p><a href="https://github.com/facebook/WebDriverAgent" target="_blank" rel="external">https://github.com/facebook/WebDriverAgent</a><br>facebook开源的自动化驱动框架, 调的私有Api,所以执行的速度应该说是最准的,这也是这套玩法的关键点<br>需要一些环境依赖,代码clone下来之后, 得在项目路径下执行下:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./Scripts/bootstrap.sh</div></pre></td></tr></table></figure></p><p>xcode打开,选择Target是WebDriverAgentRunner,Test到手机(签名用个人Appid就可以,然后Test到手机后,信任一下证书)<br><img src="/2017/12/30/wda玩微信跳一跳/wdaAgent.png" alt=""></p><h4 id="facebook-wda"><a href="#facebook-wda" class="headerlink" title="facebook-wda"></a>facebook-wda</h4><p><a href="https://github.com/openatx/facebook-wda" target="_blank" rel="external">https://github.com/openatx/facebook-wda</a><br>wda,一个python脚本,配合WebDriverAgent使用,便捷的安装方法:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip install --pre facebook-wda</div></pre></td></tr></table></figure></p><h4 id="测试下环境"><a href="#测试下环境" class="headerlink" title="测试下环境"></a>测试下环境</h4><p>用个终端端口转发下(iproxy 可以通过 brew install usbmuxd安装):<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iproxy 8100 8100</div></pre></td></tr></table></figure></p><p>用以下命令启动下WebDriverAgent,你需要改下下方的name=你自己的手机名:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcodebuild -project WebDriverAgent.xcodeproj -scheme WebDriverAgentRunner -destination 'platform=iOS,name=YourDeviceName' test</div></pre></td></tr></table></figure></p><p>看到输出这个就启动正常了:<br><img src="/2017/12/30/wda玩微信跳一跳/startAgent.png" alt=""></p><p>另开个终端,启动下python,如下测试下:<br><img src="/2017/12/30/wda玩微信跳一跳/pyhonTest.png" alt=""></p><h3 id="脚本实现"><a href="#脚本实现" class="headerlink" title="脚本实现:"></a>脚本实现:</h3><p><a href="https://github.com/Paulswith/ToolsScript/tree/master/Wechat_jump_game" target="_blank" rel="external">git代码地址-python3.6.3</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">IMAGE_PLACE = <span class="string">'/tmp/screen.png'</span></div><div class="line">each_pixel_d = <span class="number">0.00190</span></div><div class="line"></div><div class="line">c = wda.Client()</div><div class="line">s = c.session(<span class="string">'com.tencent.xin'</span>)</div><div class="line">input(<span class="string">"请自行切换到游戏里面的界面,回车即可开始"</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_to_duration</span><span class="params">(position_list)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    勾股定理 求d=C=开根号(A^2+B^2)</span></div><div class="line"><span class="string">    """</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> position_list:</div><div class="line">        <span class="keyword">return</span></div><div class="line">    x1,y1 = position_list[<span class="number">0</span>]</div><div class="line">    x2,y2 = position_list[<span class="number">1</span>]</div><div class="line">    the_d = math.sqrt(math.pow(y2 - y1, <span class="number">2</span>) + math.pow(x2 - x1, <span class="number">2</span>))</div><div class="line">    <span class="keyword">return</span> float(<span class="string">'%.3f'</span> % (the_d * each_pixel_d))</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="keyword">while</span> <span class="number">1</span>:</div><div class="line">        x = c.screenshot(IMAGE_PLACE)</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(IMAGE_PLACE):</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        <span class="comment"># time.sleep(1)  #图片就算在了,渲染还没结束,这1秒阻塞就给了吧,或者不给,为渲染正常的以下方阴影为准</span></div><div class="line">        pl.imshow(pl.array(Image.open(IMAGE_PLACE)))</div><div class="line">        position_list = pl.ginput(<span class="number">2</span>,timeout=<span class="number">2147483647</span>)</div><div class="line">        pl.ion()</div><div class="line">        duration = change_to_duration(position_list)</div><div class="line">        pl.ioff()</div><div class="line">        <span class="keyword">if</span> duration <span class="keyword">and</span> os.path.exists(IMAGE_PLACE):</div><div class="line">            s.tap_hold(<span class="number">200</span>, <span class="number">200</span>, duration=duration)</div><div class="line">            os.remove(IMAGE_PLACE)</div></pre></td></tr></table></figure><p>首先进入到游戏页面,截图到本地<br>使用plt.imshow展示这张图片, 通过plt.ginput我们点击的两个点会被记录下来,<br>我们通过分析这两个点, 得到小人到对面物体的地点:<br>嗯, 勾股定理:<br><img src="/2017/12/30/wda玩微信跳一跳/calcuC.png" alt="">   </p><p><code>change_to_duration</code>中先勾股计算的距离d,  然后乘以每个像素点的对应的秒, <code>each_pixel_d = 0.00190</code>是我目前计算到的.应该算还挺准.最后这个方法返回的是按键时间.<br>而最终操作的方法:<br><code>s.tap_hold(200, 200, duration=duration)</code> durantion就是<code>change_to_duration</code>计算出的按键时间.</p><h3 id="直接使用"><a href="#直接使用" class="headerlink" title="直接使用"></a>直接使用</h3><p>启动后只需要做三步, 点击小人的底部,点击前方物体的中心,然后关闭图, 嗯就可以了, 耐心点,还是可以在朋友圈装一下下的.<br><img src="/2017/12/30/wda玩微信跳一跳/the_d.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;… 等我写完这个脚本,刷到了372分, 才发现Android的大佬们早就有一套操作了, 似乎想法都差不多,我的环境是在ios-mac上执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;安装环境&quot;&gt;&lt;a href=&quot;#安装环境&quot; class=
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="自动化" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>探探逆向之旅</title>
    <link href="http://yoursite.com/2017/12/18/%E6%8E%A2%E6%8E%A2%E9%80%86%E5%90%91%E4%B9%8B%E6%97%85/"/>
    <id>http://yoursite.com/2017/12/18/探探逆向之旅/</id>
    <published>2017-12-18T07:27:30.000Z</published>
    <updated>2017-12-18T10:01:55.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一阵子下来才明白,逆向其实会上瘾,尤其是我这种~ 天生就爱搞破坏的坏孩子来讲<br>探探是一个社交APP, 似乎不少人在上面找到另一半的. 这种卡片社交简单,背后隐藏的推荐逻辑,筛选逻辑才是它能如此盛名的原因.<br>要重点说明,这些需求是我一产品的同学给我提的, 绝非个人偏好~ 我不是那种人…</p></blockquote><h3 id="梗概"><a href="#梗概" class="headerlink" title="梗概"></a>梗概</h3><h4 id="先上下图"><a href="#先上下图" class="headerlink" title="先上下图"></a>先上下图</h4><p>(功能入口在 新手引导-&gt;探探怎么玩-&gt; ):<br><img src="/2017/12/18/探探逆向之旅/genggai.png" alt=""><br>这是目前逆向后我给它新增的功能,因为工作也比较忙,就没有新增过多的需求,但是整个App的架构逻辑其实已经很清晰了, 基本可以合理的新增一些需求在里面, 这也说明探探的开发架构逻辑挺棒的.</p><h4 id="功能简介"><a href="#功能简介" class="headerlink" title="功能简介"></a>功能简介</h4><p><img src="/2017/12/18/探探逆向之旅/geng.png" alt=""><br>下方是一个简单的tableview, 功能的启动都在这里,当然功能是有互斥和优先级的, </p><ul><li>同时开启无条件选妹和选妹子onlyStudent, 无条件选妹子优先. </li><li>为了更好的效果在主页的地方选妹子,我最后采取的是模拟点击likeButton,在NSTimer中执行,当刷的人对已拉取用户求余==0的时候停止, 如果不想停止就把infinite打开,这是一个疯狂的爬取,没有停止的线性条件,除非杀APP. 为什么这么做呢, 因为我把自动拉取的信息默认是保存到Document/cache.txt里面, 主要是照片的url和部分简介</li><li>自动尬聊采用的是图灵的API, 你拿到源码后需要替换为您的key, 谷歌搜索”图灵机器人”,打开后进入到某个想聊天的窗口, 它如果收到信息会自动跟她尬聊.</li><li>上方是用Mapkit,新增Mapview在上方,用来更改定位,然后下面的打开(不过测了下证明这块功能还有点问题的,有兴趣的哥们继续挖掘下)</li></ul><h3 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h3><h4 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h4><ul><li>依然是最酷的<a href="https://github.com/AloneMonkey/MonkeyDev" target="_blank" rel="external">MonkeyDev </a></li><li><a href="https://github.com/Flipboard/FLEX" target="_blank" rel="external">FLEX</a>(reveal过期了,这是一个很棒的替代品), 下载后编译一下, 然后按照monkeyDev中wifi加入第三方库的方式操作即可</li><li><a href="https://github.com/AloneMonkey/frida-ios-dump" target="_blank" rel="external">frida-ios-dump</a> 还是庆哥出品,砸壳后顺带把整个APP导出</li><li>其它的全程是cycript+LLDB调戏 就不累述了…<br><img src="/2017/12/18/探探逆向之旅/flex.png" alt=""> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#import &lt;FLEX/FLEXManager.h&gt;</div><div class="line">// open it in here</div><div class="line"> [[FLEXManager sharedManager] showExplorer];</div></pre></td></tr></table></figure></li></ul><p>导入库之后,在注入成功的这个通知回调里,启动这个方法</p><h4 id="调试遇到的问题"><a href="#调试遇到的问题" class="headerlink" title="调试遇到的问题"></a>调试遇到的问题</h4><p>探探是有反调试的, 用的是sysctl. 很强<br>那么你调试的时候需要讲MonkeyDev里面的打开, 这个反反调试检测默认是关闭的,原因注释上有<br><img src="/2017/12/18/探探逆向之旅/syscall.png" alt=""></p><h4 id="从需求粗发的debug"><a href="#从需求粗发的debug" class="headerlink" title="从需求粗发的debug"></a>从需求粗发的debug</h4><p>逆向App,我一般的套路都是酱紫.<br>设计需求 -&gt;  需求在哪里会展示 -&gt; 从view到Controller-&gt; controller方法猜测 -&gt; 结合monkeyDev进行方法trace -&gt; 确认需求方法 -&gt; hopper找方法地址 -&gt;  LLDB调试下断点 -&gt; 查看调用栈(bt) -&gt; 然后开始埋点尝试hook<br><img src="/2017/12/18/探探逆向之旅/xuxu.png" alt=""><br>用笔记在记录每次你发现的新宇宙(虽然开始的很早,实际没有时间弄它…)</p><h3 id="HookKKK"><a href="#HookKKK" class="headerlink" title="HookKKK"></a>HookKKK</h3><h4 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h4><h5 id="hook位置"><a href="#hook位置" class="headerlink" title="hook位置:"></a>hook位置:</h5><p>入口开关之所以选在 [新手引导-&gt;探探怎么玩-&gt;], 因为很符合呀,介绍都免了<br><img src="/2017/12/18/探探逆向之旅/access.png" alt=""><br>就是找到控制器后,发现这里是tableview , 直接hook了tableview的代理方法, == 0的时候进入.</p><h5 id="UI层设计"><a href="#UI层设计" class="headerlink" title="UI层设计:"></a>UI层设计:</h5><p>上方是mapview, 这本身就是一个内存问题,地图App都知道, 所以在dismiss的位置,需要很”干净”的把它清理一下.<br><img src="/2017/12/18/探探逆向之旅/close.png" alt=""><br>下方是tableView, 还是很简单cell注册来循环利用,省点内存</p><h4 id="人物存储的方式"><a href="#人物存储的方式" class="headerlink" title="人物存储的方式"></a>人物存储的方式</h4><p>探探采取CoreData进行本地存储,用户的模型是<code>UserObject</code><br><img src="/2017/12/18/探探逆向之旅/user.png" alt=""><br>简要一些浅层面我所看到的:</p><ul><li>其实又有<code>ProfileInfo</code>存储用户的一些社会内容, 里面又包含学校信息在模型<code>StudiesInfo</code>和工作信息模型<code>WorkInfo</code></li><li><code>LocationInfo</code>是用户的地理信息</li><li><code>MembershipInfo</code>似乎探探在一轮融资后要开启会员模式是真的</li><li><code>SettingsInfo</code>主要是你自己的一些信息,就是设置里面的,包含要不要阻拦联系人等</li><li>其他深一点层面诸如<code>RelationshipObject</code>/<code>HiddenUsersCollection</code>,等着有需要的去挖掘<br>其实这些都能座位你来筛选的网格,只不过你想怎么操作罢了</li></ul><h4 id="自动划妹子"><a href="#自动划妹子" class="headerlink" title="自动划妹子"></a>自动划妹子</h4><p><code>P1HomeNearbyViewController</code>是我们一进去的时候的控制器,我在<code>viewDidAppear</code>是时候进行了逻辑判断, 逻辑设置项来自<code>自定义入口</code>所写到的本地缓存,<code>1 - 0</code>字符串存储的方式进行boolValue处理:<br>全局的几个定义:<br><img src="/2017/12/18/探探逆向之旅/hong.png" alt=""><br>设置YES(1) or NO(0) 来存储:<br><img src="/2017/12/18/探探逆向之旅/value.png" alt=""><br>那么通过这样子,我们就能进行全局的逻辑判断了:<br><img src="/2017/12/18/探探逆向之旅/huameizi.png" alt=""></p><p>其中,我把这些我需要hook用到的头文件,从class-dump出来的抽出来, 进行@interface一下,来欺骗编译器,如果是@property就不需要继承什么, 如果是方法,报错的话可能需要继承NSObject或其他已定义的:<br><img src="/2017/12/18/探探逆向之旅/dingyi.png" alt=""></p><p>用起来的时候就跟正向开发很像了,你熟悉的味道:<br><img src="/2017/12/18/探探逆向之旅/use.png" alt=""><br>其中有尝试刷妹子这里,如果直接调用响应后的方法刷卡片, 会有一系列问题,最后认怂直接是模拟点击的.而且为什么用NSTimer而不是for循环之类呢,可能就是runloop层的概念了,当前运行NOPro,有兴趣的自行调戏<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[likeButton sendActionsForControlEvents:[likeButton allControlEvents]];</div></pre></td></tr></table></figure></p><h4 id="改定位"><a href="#改定位" class="headerlink" title="改定位"></a>改定位</h4><p>该定位和大多数的App一样,但是探探有点麻烦的是我一直就没有刷出来地图过, (听说是触发”擦肩而过”这个业务逻辑才会展示地图),业务不熟真的很不好玩~<br>因为上层展示卡片的控制器是<code>P1HomeLookingViewController</code>,我直接trace到他有返回了信息:<br><img src="/2017/12/18/探探逆向之旅/fenxi.png" alt=""></p><p>所以我也姑且很粗糙的做了hook,Mapview保存到配置的经纬度,在这里转为double值并返回:<br><img src="/2017/12/18/探探逆向之旅/location.png" alt=""></p><p>手动创建自定义的CLLocation对象,返回给它,核心方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CLLocation *lacationInfo = [[CLLocation alloc] initWithLatitude:latitude.doubleValue longitude:longitude.doubleValue];</div></pre></td></tr></table></figure></p><h4 id="自动尬聊"><a href="#自动尬聊" class="headerlink" title="自动尬聊"></a>自动尬聊</h4><p>尬聊是一门技术, 猿不懂, 那找会的来帮忙吧~~<br>目前实现的单个尬聊, 多个尬聊尚存在问题, 且在有限的时间内就给到这样子的需求了<br><img src="/2017/12/18/探探逆向之旅/galiao.png" alt=""><br>网络请求很粗糙了使用了NSURLSession,但能保证内存是不会问题.<br><code>#pragma mark - HOOK =&gt; &quot;-[P1ConversationTableView controller:didChangeObject:atIndexPath:forChangeType:newIndexPath:]&quot;</code><br>这个方法其实未必是很合理hook地点, 原因是存在多次抛的通知, 我进行了过滤后才拿到那条到底是她刚才发的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ConversationObject *conversation = [self conversationObject];</div><div class="line">NSComparisonResult compareResult = [[conversation latestReceivedTime] compare:[conversation latestReadMessageCreatedTime]];</div><div class="line">if (compareResult == NSOrderedDescending &amp;&amp; !conversation.isRead &amp;&amp; ![arg2.owner isCurrentUser]) &#123;</div><div class="line">            NSString *message = conversation.messageCollection.latestNormalMessage.message;</div><div class="line">            NSString *lastMessage = [TT_CONFIG objectForKey:LAST_MESSAGE];</div><div class="line">            if (![lastMessage isEqualToString:message]) &#123;  //  这里会收到重复的通知 ,可能这里并不是最佳hook的位置</div></pre></td></tr></table></figure></p><ul><li>conversation是消息的模型,每条信息对应一个conversation,第一个过滤<code>本条消息的创建时间</code> 和 <code>上条已读消息的创建时间</code>比对</li><li>消息不能是已读</li><li>消息的发送者不是自己</li><li>本条消息和配置的消息不同(确认是新的消息后回保存到配置,完整字符串比较)</li></ul><p>在确认是最新消息后, 通过图灵机器人的接口, POST请求出去,剩下的就是解包-&gt; 调方法发回去,其中主要的是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">P1MessagesViewController *messageVC = (P1MessagesViewController *)[self.superview nextResponder];</div></pre></td></tr></table></figure></p><p>发送消息的方法在P1MessagesViewController,为了找到它,可真是废了一把劲, 最后就是这么简单</p><p>ano: 尬聊木有真实妹子,都是探探小助手帮的我 谢谢哦</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>逆向真的会让人上瘾 , 主要的是保持你”猥琐的”好奇心~ , 工具的使用可能都差不多,训练的是一种敏感, 对方法敏感诸如此类呀<br>从逆向我们能快速知道别人的需求做了什么,  快速了解别人的业务等,是一种很高效快速的熟悉方式.<br>至此告一段落,代码直接见我的GIT <a href="https://github.com/Paulswith/ToolsScript/tree/master/tantan_project" target="_blank" rel="external">tantan_project</a></p><p>[<code>仅供学习,注意尺度</code>]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一阵子下来才明白,逆向其实会上瘾,尤其是我这种~ 天生就爱搞破坏的坏孩子来讲&lt;br&gt;探探是一个社交APP, 似乎不少人在上面找到另一半的. 这种卡片社交简单,背后隐藏的推荐逻辑,筛选逻辑才是它能如此盛名的原因.&lt;br&gt;要重点说明,这些需求是我一产品
      
    
    </summary>
    
      <category term="reverseEngineering" scheme="http://yoursite.com/categories/reverseEngineering/"/>
    
    
      <category term="逆向探探" scheme="http://yoursite.com/tags/%E9%80%86%E5%90%91%E6%8E%A2%E6%8E%A2/"/>
    
  </entry>
  
  <entry>
    <title>mac逆向-窗口管理Divvy</title>
    <link href="http://yoursite.com/2017/12/03/mac%E9%80%86%E5%90%91-%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86Divvy/"/>
    <id>http://yoursite.com/2017/12/03/mac逆向-窗口管理Divvy/</id>
    <published>2017-12-03T09:57:54.000Z</published>
    <updated>2017-12-03T14:51:55.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Divvy个人感觉是最棒的一款窗口管理软件了~, 但是它动不动就会提示个五秒的窗口让你注册License,最近小试牛刀完IOSApp, 它给我提供一个入门的机会…</p></blockquote><h3 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h3><p><img src="/2017/12/03/mac逆向-窗口管理Divvy/predic.png" alt=""><br>mac上的逆向其实比较省, 你不需要额外的砸壳,直接就能能从包里面拿到执行文件.<br>class-dump 头文件.<br>用Hopper打开,反汇编一下方便待会查看.<br>然后神器依旧是monkeyDev, 它帮我们省去注入.dylib 和 重签名等”繁杂步骤”~</p><h3 id="入口分析"><a href="#入口分析" class="headerlink" title="入口分析"></a>入口分析</h3><p>本来大多数的步骤一定是从view开始, 有一款神器就[interface inspector], 但总会报错一些乱七八糟的问题,暂时还没调好, 于是乎我粗糙的从hopper搜索”Register”,(如果一开始搜的是首字母小写的话可能不会饶那么弯…),结果是这样子的,<br><img src="/2017/12/03/mac逆向-窗口管理Divvy/first.png" alt=""><br>也查到其他无关的,最后确定就是这里,伪代码和汇编看并没有看出什么头绪,于是乎先看看有没有调用这里这个类相关.</p><p>追踪前,这里有一款强大的工具说下:<br><code>frida-trace</code>: frida-trace -m “-[PTHotKeyCenter <em>]”  Divvy<br><img src="/2017/12/03/mac逆向-窗口管理Divvy/frida.png" alt=""><br>用法是frida-trace -m “&lt;+类方法/-实例方法&gt;[类名 方法名&lt;</em>代表全部&gt;]”  <ps aux查询到的允许名=""><br>执行后它会自动帮你生成跟踪的js文件,然后监听所指定的方法.</ps></p><p>一开始觉得吧, PTHotKeyCenter不像是很关键的类, 也是没怎么写Mac的App的原因,但还是监听了一下:<br><img src="/2017/12/03/mac逆向-窗口管理Divvy/trace.png" alt=""><br>我尝试打开它,然后随便输入一串号码注册, 发现他怎么整都只打印这些, 而且就在我使用快捷键的时候~<br>随意也明白了,这就是”热键”,仅此而已…</p><h3 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h3><p>进行到这里其实是无头绪的, 然后想着是从mondev进行动态调试,看看能不能从调用栈看看这里的情况.<br>想着hook哪个方法的时候,脑子冒个灵光,想到了这个view的展示, 我就输入”)show”看看有没有什么可疑的,结果:<br><img src="/2017/12/03/mac逆向-窗口管理Divvy/show.png" alt=""> 十分意外第一个方法,很明显这个方法应该是展示注册这个View的,而且还待会参数时间.<br>如果是这个方法果然没错, 那么我可能得到,一是找不到更好的hook方法,duration的参数改为最少的时间,或者可以尝试return这部展示的操作. 其次先Hook下看看调用栈,是什么决定它展示也是可以的, 于是开始我的Hook代码.<br>MonkeyDev默认是subStrate的hook方法代码, 当然也是可以替换成其它的(按道理当然可以~):<br>这是一开始的代码:<br><img src="/2017/12/03/mac逆向-窗口管理Divvy/array.png" alt=""><br>但是允许会报错,其中需要修改:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static void newHookFunc(AppController* self,SEL _cmd,id array)&#123; // &#125;</div><div class="line">                    //replacet to | //下面</div><div class="line">static void newHookFunc(AppController* self,SEL _cmd,id arg1, id arg2)&#123; // &#125;</div><div class="line">// 需要指明多少个参数, 不知道参数类型就使用泛型id</div></pre></td></tr></table></figure></p><p>build一下且进入调试后, 用时在<code>static void newHookFunc(AppController* self,SEL _cmd,id arg1, id arg2){</code> 这里Xcode断点一下:<br>但如果直接执行还需要做两部:</p><ul><li>关闭原程序</li><li>如果类似这种辅助类APP,需要到系统中关闭它的辅助项.</li><li>可能你还不熟悉如何进入调试macApp ,那快去翻一下MonkeyDev的wiki,或者见文末</li></ul><p>然后进入注册页面,果不其然的断点触发.然后我打印了一下调用栈:<br><img src="/2017/12/03/mac逆向-窗口管理Divvy/stack.png" alt=""><br>是的,一眼看去都是非Divvy调用栈的可用信息~ 有点陷入僵局了.</p><h3 id="人品才是最高逆向"><a href="#人品才是最高逆向" class="headerlink" title="人品才是最高逆向"></a>人品才是最高逆向</h3><p>有点朦胧的时候, 我回到<code>- (void)showLicensingWindow:(id)arg1 withTimeoutDuration:(int)arg2;</code>这个方法中, 结果真的很意外,其中有个地方很雷人:<br><img src="/2017/12/03/mac逆向-窗口管理Divvy/ok.png" alt=""><br><code>- (BOOL)verifyLicense;</code>这真的不能再明白的一个方法了,不管是不是依然开始Hook一下.mac的逆向就是各种Hook~<br>hook代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#import &quot;Divvy.h&quot;</div><div class="line">#import &quot;substrate.h&quot;</div><div class="line"></div><div class="line">@class AppController;</div><div class="line"></div><div class="line">static BOOL (*originFunc)(AppController*,SEL,id);</div><div class="line">static BOOL newHookFunc(AppController* self,SEL _cmd,id array)&#123;</div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void __attribute__((constructor)) initialize(void) &#123;</div><div class="line">    MSHookMessageEx(objc_getClass(&quot;AppController&quot;),@selector(verifyLicense), (IMP)&amp;newHookFunc, (IMP*)&amp;originFunc);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>依然Build一下跑起来, 真的很意外,因为启动的时候默认也是要弹一次注册框的, 这次启动并没有,启动后直接什么也展示(而且我忘记断点了). 手动选到注册框看一下怎么肥事:<br><img src="/2017/12/03/mac逆向-窗口管理Divvy/finish.png" alt=""><br>真的很意外, 就像小黄书的作者狗神中说的,运气也是逆向的一部分.嗨森~</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>谁说人品不是逆向的一部分呢, 实践就能找到快乐.第一次Mac的调试竟然这么快就收获自我成就感,赚到了.<br>App的话我打包上传到<a href="https://github.com/Paulswith/ToolsScript/tree/master/Divvy_windowManagerTool" target="_blank" rel="external">这里</a></p><p>特别鸣谢大佬协助:<br><a href="https://github.com/AloneMonkey/MonkeyDev/wiki/Mac%E5%BA%94%E7%94%A8%E6%8F%92%E4%BB%B6" target="_blank" rel="external">monkeyDev之MAC应用</a><br><a href="http://www.alonemonkey.com/2017/05/31/get-start-with-mac-reverse/" target="_blank" rel="external">庆哥的一篇文章走进MAC逆向</a><br><a href=""><code>膜庆哥</code></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Divvy个人感觉是最棒的一款窗口管理软件了~, 但是它动不动就会提示个五秒的窗口让你注册License,最近小试牛刀完IOSApp, 它给我提供一个入门的机会…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;工具准备&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="reverseEngineering" scheme="http://yoursite.com/categories/reverseEngineering/"/>
    
    
      <category term="macApp-Divvy破解" scheme="http://yoursite.com/tags/macApp-Divvy%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>UNREAD逆向-去除阅读限制</title>
    <link href="http://yoursite.com/2017/11/28/Unread%E9%80%86%E5%90%91-%E5%8E%BB%E9%99%A4%E9%98%85%E8%AF%BB%E9%99%90%E5%88%B6/"/>
    <id>http://yoursite.com/2017/11/28/Unread逆向-去除阅读限制/</id>
    <published>2017-11-28T13:25:31.000Z</published>
    <updated>2017-11-29T01:33:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>背景 : UNREAD是一款很棒的RSS阅读器, 免费版本有50条阅读的限制. 强化在非越狱机上的逆向之旅<br>因为是巩固逆向的知识阶段,踩坑是必然的, 但是多么绕的就不讲了, 但是要mark最后走对这个方式,后面也要逐渐总结对的方法</p></blockquote><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>UNREAD要求ios10以上才可以下载,所以我的935设备无法下载也无法砸壳, 所幸的是PP助手能搜到,不过版本低了0.2, 用起来没差别.</p><blockquote><p>确认需求 :  去除阅读限制</p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="正向分析思路"><a href="#正向分析思路" class="headerlink" title="正向分析思路"></a>正向分析思路</h4><p><img src="/2017/11/28/Unread逆向-去除阅读限制/no.png" alt=""><br>如果是我设计呢:<br>    目标是个tableview , “UNLOCK UNREAD”这一cell显示了当前剩余可阅读的数量.每次点击进入文章阅读的时候,可读数量 -= 1; 有一个模型来记录这里的数量,<br>在tableview这个控制器,viewWillApear:的时候刷新row.</p><p>当时想的是:<br>那么如果是tableiview, dataSource方法必然有tableview:cellForRowAtIndexPath:被调用, 如果能找到模型,直接hook模型的调用或许是第一思路.但是熬到三点还没睡我才明白我踩坑了, 这里不累赘了,一把泪. </p><h4 id="view层嵌入"><a href="#view层嵌入" class="headerlink" title="view层嵌入"></a>view层嵌入</h4><p>从monkeyDev启动项目,拖入我们的APP后启动到设备上, 默认是会注入reveal动态库的, APP启动成功后, 进入到主页, 然后mac启动reveal:<br><img src="/2017/11/28/Unread逆向-去除阅读限制/reveal.png" alt=""><br><img src="/2017/11/28/Unread逆向-去除阅读限制/ravealVC.png" alt=""></p><p>reveal启动后点到我们目标view,可以看到这是一个tableview的cell,”50 ARTICLES LEFT”是cellContentView的label, 查看右边, 我们能看到这个页面的控制器.<br>“NSRHomeViewController”</p><h4 id="分析控制器"><a href="#分析控制器" class="headerlink" title="分析控制器"></a>分析控制器</h4><p>把class-dump出来的头文件拖到Xcode项目, 搜一下”NSRHomeViewController.h”可以看到这个头文件, 所幸头文件不多,我有了部分时间慢慢看这些方法,尝试发现敏感名称, 其中最让我敏感的是这个:<br><img src="/2017/11/28/Unread逆向-去除阅读限制/array.png" alt=""><br><img src="/2017/11/28/Unread逆向-去除阅读限制/method.png" alt=""><br>第二个方法这未免太明显~, 其它大概也预览了一下, 图一看到是NSArray, 或许会存储数据的模型.</p><h4 id="断点可疑调用"><a href="#断点可疑调用" class="headerlink" title="断点可疑调用"></a>断点可疑调用</h4><p>二进制文件拉到Hopper反汇编后, 搜一下三个方法</p><blockquote><p>moreItems &amp; setMoreItems &amp; updateUnlockInfo</p></blockquote><p>获取它们的静态地址后,在LLDB查看下初始偏移地址, 加上并断点这三位.<br>分析的时候知道, 它是在点击文章阅读的时候才减一. 那么现在就进入文章里面,触发我们的断点. 果不其然它触发了,查看一下调用栈:<br><img src="/2017/11/28/Unread逆向-去除阅读限制/stack.png" alt=""></p><p>其中#0一定是我们当前被调用的方法, 那是谁呢?<br>嗯,就是<code>updateUnlockInfo</code><br><img src="/2017/11/28/Unread逆向-去除阅读限制/soudao.png" alt=""><br>回溯上层的调用栈, 初步我们先查看下这些Unread模块的栈,看看是否我们调用的信息.分别减去初始偏移量后他们依次是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-[UNRPermissionManager setRemainingCount:]</div><div class="line">-[UNRPermissionManager permissionToReadArticleWithUniqueID:]</div><div class="line">-[UNRArticlesListViewController showArticleViewer]</div><div class="line">-[UNRArticlesListViewController deadEndTapTimerFired:]</div></pre></td></tr></table></figure></p><h4 id="逻辑梳理"><a href="#逻辑梳理" class="headerlink" title="逻辑梳理"></a>逻辑梳理</h4><p>hopper查看一下updateUnlockInfo的伪代码:<br><img src="/2017/11/28/Unread逆向-去除阅读限制/updateINFO.png" alt=""><br>发现它只是负责调用reloadSection这个刷新动作,说明数据操作在上层<br>因此继而hopper查看一下 <code>setRemainingCount:</code><br><img src="/2017/11/28/Unread逆向-去除阅读限制/remain.png" alt=""><br>我们可以看到他的参数只有一个,而且是unsinged long long 类型, 猜测他是又负责调用传递的参数,而这个参数可能就是需要更新的数量.<br>那么线索就继续追溯到上层调用<code>permissionToReadArticleWithUniqueID</code>, 从hopper找到并查看,翻开伪代码可以看到如下:<br><img src="/2017/11/28/Unread逆向-去除阅读限制/remainFromHere.png" alt=""><br>setRemainingCount:是这里调的, 而且发现UNREAD不仅记录未使用的次数,还记录了已使用的次数,如果过早的Hook<code>setRemainingCount:</code>应该是起不了作用的.<br>仔细观察这一代码段,发现这里只有一个return出口,且存在多个逻辑判断跳转分支,可以配合hopper的逻辑视图看到:<br><img src="/2017/11/28/Unread逆向-去除阅读限制/jumpPic.png" alt=""></p><blockquote><p>从伪代码结合汇编来看, 这里就是我们的目标了, 但我们怎么挑选这些分支呢? 个人觉得是三点:<br>1 首先我们知道我们要hook,大多时候是针对方法, 如果一个分支的逻辑是被某个特定的方法可以扭转的,基本上它就是我们想要的.<br>2 其次是对整个逻辑改动最小的, 不要影响其他的功能实现.<br>3 我们能比较稳妥确定的逻辑.猜可不能解决所有问题.</p></blockquote><h4 id="分析hook点"><a href="#分析hook点" class="headerlink" title="分析hook点"></a>分析hook点</h4><p>这里其实也是比较贪婪操作了, <code>?&lt;</code> 看图:<br><img src="/2017/11/28/Unread逆向-去除阅读限制/UP.png" alt=""><br>对比后发现第一个分支的逻辑比较清晰:<br><code>storeCountry</code>返回了一个string类型, 与0x100289de0这个地址的值进行了比较, 如果相等则直接跳转到地址<code>0x10013e714</code>,并赋值为<code>0x1</code>即不为假的, 继而跳转到<code>0x10013e718</code>,返回真.<br> 从最简单的来看,这个方法绕开<code>remainingCount</code>不会导致阅读文章的时候可阅读数量 -= 1. 其实到这里基本就能实现我们的功能了, 只要让<code>storeCountry</code>返回0x100289de0一样的字符串就可以了.<br>so , 继续看看<code>storeCountry</code>的返回逻辑,依旧常规Hopper搜方法:<br><img src="/2017/11/28/Unread逆向-去除阅读限制/store.png" alt=""><br>从UNRKeyChain获取的一个字符串,如果等于”:happysquid:”的话就返回”:happysquid:”,不然就返回这个<code>&amp;0x100284130</code>, 就这两种情况. </p><p>0x100289de0是一个静态地址,直接搜一下:<br><img src="/2017/11/28/Unread逆向-去除阅读限制/place.png" alt=""><br>也是”:happysquid:”, 到这里基本就可以大胆试一试了.</p><h3 id="hook代码"><a href="#hook代码" class="headerlink" title="hook代码"></a>hook代码</h3><p>全部的Hook代码如下, copy执行即:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@interface UNRIAPManager</div><div class="line">- (NSString *) storeCountry;</div><div class="line">@end</div><div class="line"></div><div class="line">CHDeclareClass(UNRIAPManager)</div><div class="line">CHOptimizedMethod(0, self, NSString*, UNRIAPManager,storeCountry)&#123;</div><div class="line">    NSLog(@&quot;is hook succeed? -- -------------------&quot;);</div><div class="line">    return @&quot;:happysquid:&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">CHConstructor&#123;</div><div class="line">    CHLoadLateClass(UNRIAPManager);</div><div class="line">    CHClassHook(0, UNRIAPManager, storeCountry);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>思路就是直接Hook<code>storeCountry</code>,让其永远返回”:happysquid:”,这里似乎也是比较粗糙的做法(如何这里是后台动态下发呢? ),但换个思路想, 这里返回”:happysquid:”,逻辑的意思就是 “I’m the VIP” 的暗号,既然如此何乐不为. 碰碰运气跑一下看看. 这不就是逆向的随机性乐趣所在吗…<br>尝试就是收获,目前自用并未发现问题.几乎天天在这里APP里面看前辈文章的,稳的</p></blockquote><p>看下执行效果:<br><img src="/2017/11/28/Unread逆向-去除阅读限制/succeed.png" alt=""><br>半意外收获,这里的提示语也没有了,所以说明我的猜测是对的.<br>其实hook代码的就这么几行, 但是逻辑的分析却耗了我一个熬到3点钟的晚上, 小小成就给自己泡一杯咖啡吧.</p><h3 id="简单总结下"><a href="#简单总结下" class="headerlink" title="简单总结下"></a>简单总结下</h3><h4 id="乐观的"><a href="#乐观的" class="headerlink" title="乐观的"></a>乐观的</h4><p>1 成功的入口主要是<code>updateUnlickInfo</code>这个清晰可爱的方法和方法的调用栈, 我们可以通过调用栈来回溯层次调用逻辑,找到可以被hook的突破口.<br>2 实战才是领悟真谛的唯一途径. 通过本次实战, 逆向的思路更加清晰了, hopper一些反汇编工具调整好正确打开的姿势.</p><h4 id="悲观的"><a href="#悲观的" class="headerlink" title="悲观的"></a>悲观的</h4><p>1 本次逆向的时候比较长,大约耗费15个小时+(失去的还有很差的脸色),其中对于monkeyDev集成不太熟练,LLDB插件chisel是个可以提升点.<br>2 UNREAD如此明文的存储确实在安全的思路太过单纯了,或许在新版本已经修复了(这是从PP助手下载的1.6,新版本的是1.8的样子).</p><p>[<code>逆向之旅NICE</code>]<br>后面会谈谈如何加密敏感数据.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;背景 : UNREAD是一款很棒的RSS阅读器, 免费版本有50条阅读的限制. 强化在非越狱机上的逆向之旅&lt;br&gt;因为是巩固逆向的知识阶段,踩坑是必然的, 但是多么绕的就不讲了, 但是要mark最后走对这个方式,后面也要逐渐总结对的方法&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="reverseEngineering" scheme="http://yoursite.com/categories/reverseEngineering/"/>
    
    
      <category term="逆向UNREAD" scheme="http://yoursite.com/tags/%E9%80%86%E5%90%91UNREAD/"/>
    
  </entry>
  
  <entry>
    <title>砸壳最稳dumpdecrypted</title>
    <link href="http://yoursite.com/2017/11/24/%E7%A0%B8%E5%A3%B3%E6%9C%80%E7%A8%B3dumpdecrypted/"/>
    <id>http://yoursite.com/2017/11/24/砸壳最稳dumpdecrypted/</id>
    <published>2017-11-24T13:17:28.000Z</published>
    <updated>2017-11-24T13:53:53.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前写过一篇<a href="https://paulswith.github.io/2017/11/17/clutch%E5%AF%B9app%E8%BF%9B%E8%A1%8C%E7%A0%B8%E5%A3%B3/" target="_blank" rel="external">clutch砸壳</a>的, 但clutch似乎没有100%成功的情况, 所以还是得老司机来.</p></blockquote><h3 id="编译得到-dylib"><a href="#编译得到-dylib" class="headerlink" title="编译得到.dylib"></a>编译得到.dylib</h3><p><a href="https://github.com/stefanesser/dumpdecrypted" target="_blank" rel="external">https://github.com/stefanesser/dumpdecrypted</a><br>下载后<code>make</code>一下会生成一个.dylib<br><img src="/2017/11/24/砸壳最稳dumpdecrypted/build.png" alt=""></p><h3 id="拷贝到设备上"><a href="#拷贝到设备上" class="headerlink" title="拷贝到设备上"></a>拷贝到设备上</h3><p><code>iproxy 2222 22</code><br>开启一个映射后:<br><code>scp -P 2222 dumpdecrypted.dylib root@localhost:/tmp/</code></p><h3 id="获取App目录"><a href="#获取App目录" class="headerlink" title="获取App目录"></a>获取App目录</h3><p>启动下目标App,cycript到进程中, 输入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSHomeDirectory()</div></pre></td></tr></table></figure></p><h3 id="拷贝-dylib到App目录"><a href="#拷贝-dylib到App目录" class="headerlink" title="拷贝.dylib到App目录"></a>拷贝.dylib到App目录</h3><p>退出cycript,切换到App目录后:<br> 拷贝.dylib 到得到的目录:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp /tmp/dumpdecrypted.dylib  .</div></pre></td></tr></table></figure></p><p>mible用户查看进程:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">su mobile    #切换普通用户</div></pre></td></tr></table></figure></p><p><img src="/2017/11/24/砸壳最稳dumpdecrypted/quit.png" alt=""></p><h3 id="开始砸壳"><a href="#开始砸壳" class="headerlink" title="开始砸壳"></a>开始砸壳</h3><p>启动下App,然后:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -e  | grep /Application   #查看App进程,我们需要正确的二进制文件地址</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib &lt;上面的二进制地址&gt;</div></pre></td></tr></table></figure><p><img src="/2017/11/24/砸壳最稳dumpdecrypted/perform.png" alt=""></p><h3 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h3><p><img src="/2017/11/24/砸壳最稳dumpdecrypted/end.png" alt=""><br><img src="/2017/11/24/砸壳最稳dumpdecrypted/end2.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;之前写过一篇&lt;a href=&quot;https://paulswith.github.io/2017/11/17/clutch%E5%AF%B9app%E8%BF%9B%E8%A1%8C%E7%A0%B8%E5%A3%B3/&quot; target=&quot;_blan
      
    
    </summary>
    
      <category term="reverseEngineering" scheme="http://yoursite.com/categories/reverseEngineering/"/>
    
    
      <category term="砸壳" scheme="http://yoursite.com/tags/%E7%A0%B8%E5%A3%B3/"/>
    
  </entry>
  
  <entry>
    <title>去除OplayerLite广告提示-越狱机</title>
    <link href="http://yoursite.com/2017/11/24/%E5%8E%BB%E9%99%A4OplayerLite%E5%B9%BF%E5%91%8A%E6%8F%90%E7%A4%BA-%E8%B6%8A%E7%8B%B1%E6%9C%BA/"/>
    <id>http://yoursite.com/2017/11/24/去除OplayerLite广告提示-越狱机/</id>
    <published>2017-11-24T09:56:29.000Z</published>
    <updated>2017-11-24T12:59:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在学习逆向相关的实践+踩坑, 庆哥的视频中一个课程是对于OPlayerLite进行进行广告处理了, 因为是去年的课程App也更新了逻辑, 我沿着先辈的道路把坑撸了一把, mark这场一天一夜的战斗.</p></blockquote><h3 id="分析层级结构"><a href="#分析层级结构" class="headerlink" title="分析层级结构"></a>分析层级结构</h3><h4 id="定位目标对象"><a href="#定位目标对象" class="headerlink" title="定位目标对象"></a>定位目标对象</h4><p>连接到越狱机(切换到无网络模式, 因为Oplayer lite有网络的时候加载的广告是不同的,不利于分析), 同时点击任意视频,进入到视频播放页面, 我们会看到广告的view,上面有一行文本”Buy the full version to remove ads?”<br>这时候我们连接到cycript打印下层级:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UIApp.keyWindow.recursiveDescription().toString()</div></pre></td></tr></table></figure></p><p><img src="/2017/11/24/去除OplayerLite广告提示-越狱机/fe.png" alt=""><br>由于我已去除了过了,又从App Store重新下载, 发现还是没有广告,图片暂时就没哈<br>其中有引起我们注意的层级是:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">|    |    | &lt;UIView: 0x17501dc0; frame = (0 0; 320 50); layer = &lt;CALayer: 0x177a8eb0&gt;&gt;</div><div class="line">|    |    |    | &lt;UIButton: 0x17778a30; frame = (0 0; 320 50); opaque = NO; layer = &lt;CALayer: 0x177a8d80&gt;&gt;</div><div class="line">|    |    |    |    | &lt;UIImageView: 0x17630de0; frame = (0 0; 320 50); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x17630ec0&gt;&gt;</div><div class="line">|    |    |    | &lt;UILabel: 0x176b1380; frame = (60 0; 260 50); text = 'Buy the full version to r...'; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x1762fc70&gt;&gt;</div></pre></td></tr></table></figure></p><p>其中<code>UILabel: 0x176b1380</code>中的text属性跟我们看到的ads上是一样的,它的同级view是UIButton, 父view是UIView .<br> 因为咱们要解决的目标是view, 尤为关注是这里的frame.size, 它们都是<code>320 50</code>, label也是height=50. 把这部分截图保存下来,待会查找的时候需要用到</p><h4 id="正向分析设计"><a href="#正向分析设计" class="headerlink" title="正向分析设计"></a>正向分析设计</h4><blockquote><p>划重点: 从正向的开发的角度, 分析它是如何设计的</p></blockquote><p>如果是我开发君, 我的伪代码大概如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if  (!payBuyFullViersion)  &#123;</div><div class="line">    AdsView *adsview =  [[AdsView alloc] init];</div><div class="line">    [self.palyerView addSubview:adsview]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可能其他的逻辑未必跟我符合. 但是一定必然的是, 这个adsView 必须是addSubview上去的,addSubview是UIKit中view的方法, 咱们需要静态分析这个地址, 通过断点来查看它对应的调用者/参数, 从而拿到地址,来定位到OplayerLite</p><h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><h4 id="从UIKit入手"><a href="#从UIKit入手" class="headerlink" title="从UIKit入手"></a>从UIKit入手</h4><p>我们需要用到lldb, 连接到设备, 查看UIKit的存储地址, 然后通过IDA查看addSubview:的静态代码地址.<br>本地先映射一下 <code>iproxy 1234 1234</code> , 然后越狱启动<code>debugserver  *:1234  -a &lt;pid&gt;</code><br><img src="/2017/11/24/去除OplayerLite广告提示-越狱机/debugS.png" alt=""><br>本地连接:<br><img src="/2017/11/24/去除OplayerLite广告提示-越狱机/lldb.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">im list -o -f</div></pre></td></tr></table></figure></p><p><img src="/2017/11/24/去除OplayerLite广告提示-越狱机/offset.png" alt=""><br>得到了Oplayer lite的偏移地址和UIKit偏移地址<br>同时我们看到了UIKit的文件地址(可能有的地址是在设备上, 那么你需要拷贝到本地,不想这样子就连一下Xcode,你就会在本地看到它了)</p><p>IDA分析UIKit, 并获取addSubview:的地址:<br><img src="/2017/11/24/去除OplayerLite广告提示-越狱机/viewadd.png" alt=""><br>在lldb下断点,记得加上上面看到的偏移,如:<br><img src="/2017/11/24/去除OplayerLite广告提示-越狱机/bradd.png" alt=""><br>然后进入到播放界面触发断点</p><h4 id="体力活查询"><a href="#体力活查询" class="headerlink" title="体力活查询"></a>体力活查询</h4><p>因为上面我们讲到<br><code>[self.palyerView addSubview:adsview]</code><br>这里的adsView是作为参数的,所以我们需要Print object r2<br>漫长的开始 <code>c</code>和粘贴 <code>po $r2</code>,一遍持续一遍注意看打印出来的frame,是不是有我们符合的<code>frame=(n,n,320,50)</code><br>这可能会很漫长,取决于当前页面子元素数量和人品~</p><p>…….<br>当你发现frame跟我们所看到符合的时候,那么基本就可以确认是它了.同时有个地方要注意:<br>你需要看到这个地址来自于Oplayer lite才可以, 否则执行以下<code>ni</code>,执行下一条汇编直到看见它<br><img src="/2017/11/24/去除OplayerLite广告提示-越狱机/fit.png" alt=""><br>而第一条指令的地址就是我们要的地址, 减去我们上面的偏移地址,拿到静态代码的地址.</p><h3 id="分析目标静态代码"><a href="#分析目标静态代码" class="headerlink" title="分析目标静态代码"></a>分析目标静态代码</h3><h4 id="对逻辑静态分析"><a href="#对逻辑静态分析" class="headerlink" title="对逻辑静态分析"></a>对逻辑静态分析</h4><p>通过上面拿到的地址, 我们可以看到这里是一个实例方法<br><code>-[PlayViewController addAds_OnLocalAds]</code><br><img src="/2017/11/24/去除OplayerLite广告提示-越狱机/addfun.png" alt=""><br>不是很仔细的看了一遍伪代码,这个方法是被调用来展示view,但是否展示的逻辑并不在这里, 我们需要看谁是它的调用方, 因为删掉之前的断点,重新在<code>-[PlayViewController addAds_OnLocalAds]</code>这个方法上下断点, 依然加上偏移地址(这里的偏移地址已经是OPlayerlite了).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">br s -a &apos;0x00052000+0x002A49F8&apos;</div><div class="line">#断点触发后, 打印lr寄存器的值</div><div class="line">p/x $lr</div></pre></td></tr></table></figure></p><p>LR寄存器(R14)可以理解当代码段执行完毕后要回到调用者的地址.<br>通过LR寄存器得到的值, 我们减去偏移地址,可以得到调用者在静态代码的位置.<br><img src="/2017/11/24/去除OplayerLite广告提示-越狱机/spass.png" alt=""><br>依然借助IDA分析, 可以看到msg_send的一些部分是相关的设置方向, frame, getWidth等方法, 而调用的位置就在viewWillAppear:这里.</p><h4 id="寻找绕弯的方法"><a href="#寻找绕弯的方法" class="headerlink" title="寻找绕弯的方法"></a>寻找绕弯的方法</h4><p>现在, 我们定位到了调用添加广告View的代码块, 继续往上翻,能不能找到帮助我们跳过这里的逻辑呢?<br>果然, 神器就是神器, 留意左边这根线:<br><img src="/2017/11/24/去除OplayerLite广告提示-越狱机/findMethod.png" alt=""><br>辅助IDA的伪代码,我们还能发现些神马:<br><img src="/2017/11/24/去除OplayerLite广告提示-越狱机/jumpCode.png" alt=""></p><blockquote><p>这里的两个跳转对应了两个逻辑判断分支, 我在图片中表明了, 逻辑2的情况其实稍加复杂, 但我在逻辑1发现了关键点:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if ( !((unsigned int)+[OlimSoftUtility isUpgraded](&amp;OBJC_CLASS___OlimSoftUtility, &quot;isUpgraded&quot;, a3) &amp; 0xFF) )</div></pre></td></tr></table></figure></p></blockquote><p>伪代码的意思是<code>+[OlimSoftUtility isUpgraded]</code>的返回值和 #0xFF 进行了逻辑与的运算, 理解到 #0xFF 是非0类型必为真, 而现在只需要<code>+[OlimSoftUtility isUpgraded]</code>能返回真即可跳过这段代码. 这个猜想是否正确,毕竟是伪代码,所以需要对汇编部分进行确认:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">__text:0029D2F8     BLX.W           _objc_msgSend ; +[OlimSoftUtility isUpgraded]</div><div class="line">__text:0029D2FC     TST.W           R0, #0xFF</div></pre></td></tr></table></figure></p><p>第一行很容易看出是发送了消息,也就是刚才说的调用了<code>+[OlimSoftUtility isUpgraded]</code>这个方法, 而第二行, 将第一行<code>+[OlimSoftUtility isUpgraded]</code> 返回值 与 0xFF进行了 <code>TST</code>指令, 对于目前汇编的底子不硬,通过查询资料得知:</p><blockquote><p>TST 指令对 Rn 中的值和 Operand2 的值按位进行“与”运算。 除了结果会被丢弃以外，这与 ANDS 指令功能相同。</p></blockquote><p>那么就基本能确定结论了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if ( ([OlimSoftUtility isUpgraded] &amp;&amp; 0xFF) == NO ) &#123;</div><div class="line">    // 添加广告</div><div class="line">&#125;</div><div class="line">// 0xFF 固定为YES</div></pre></td></tr></table></figure></p><h4 id="头文件最终确认"><a href="#头文件最终确认" class="headerlink" title="头文件最终确认"></a>头文件最终确认</h4><p>找到class-dump 出的头文件目录:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep -rn "isUpgraded" ./headers</div></pre></td></tr></table></figure></p><p><img src="/2017/11/24/去除OplayerLite广告提示-越狱机/findH.png" alt=""><br><img src="/2017/11/24/去除OplayerLite广告提示-越狱机/H1.png" alt=""><br>发现它就是一个类方法,很纯粹.那么也不用太多想法, 试试就试试了.</p><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><p><img src="/2017/11/24/去除OplayerLite广告提示-越狱机/tweek.png" alt=""></p><p>让个惊讶的tweak.xm代码:<br>“当然我这样子处理应该是会引起某些问题了, 但这是目前我分析到的能力”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">%hook OlimSoftUtility</div><div class="line"></div><div class="line">+ (BOOL)isUpgraded &#123;</div><div class="line">%log;</div><div class="line">// NSLog(@&quot;replace this method!!!!!!!!!!!!!!!!!!!&quot;);</div><div class="line">return YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">%end</div></pre></td></tr></table></figure></p><p>Makefile代码:<br>我指定了IP 和 Port, 待会可以在直接调用 make install 进行安装<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">export THEOS_DEVICE_IP=localhost    </div><div class="line">export THEOS_DEVICE_PORT=2222</div><div class="line">export ARCHS=armv7</div><div class="line">export TARGET=iphone:clang:latest:8.0</div><div class="line">export THEOS_MAKE_PATH=/opt/theos/makefiles</div><div class="line">export THEOS=/opt/theos</div><div class="line"></div><div class="line">include $(THEOS)/makefiles/common.mk</div><div class="line"></div><div class="line">TWEAK_NAME = removeOplayerAds</div><div class="line">removeOplayerAds_FILES = Tweak.xm</div><div class="line"></div><div class="line">include $(THEOS_MAKE_PATH)/tweak.mk</div><div class="line"></div><div class="line">after-install::</div><div class="line">install.exec "killall -9 SpringBoard"</div></pre></td></tr></table></figure></p><h4 id="一些小坑点"><a href="#一些小坑点" class="headerlink" title="一些小坑点"></a>一些小坑点</h4><h4 id="没找到dpkg-deb"><a href="#没找到dpkg-deb" class="headerlink" title="没找到dpkg-deb:"></a>没找到dpkg-deb:</h4><p>dpkg-deb的原名是/opt/theos/bin/dm.pl, 你需要把它的名字改为dpkg-deb,然后执行下面的语句<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">➜  removeoplayerads make package</div><div class="line">==&gt; Error: /Applications/Xcode.app/Contents/Developer/usr/bin/make package requires dpkg-deb.</div><div class="line">make: *** [internal-package-check] Error 1</div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 决绝方法</span></span></div><div class="line">➜  removeoplayerads sudo perl -i -pe 'y|\r||d' /opt/theos/bin/dpkg-deb</div><div class="line">Password:</div></pre></td></tr></table></figure></p><h4 id="BundleID最准确的获取方法"><a href="#BundleID最准确的获取方法" class="headerlink" title="BundleID最准确的获取方法"></a>BundleID最准确的获取方法</h4><p>cycript 进入到目标APP进程后:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[NSBundle mainBundle] bundleIdentifier]</div></pre></td></tr></table></figure></p><h4 id="汇编查询"><a href="#汇编查询" class="headerlink" title="汇编查询"></a>汇编查询</h4><p>干货, 大全!!!<br><a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0204ic/Cihbjcag.html" target="_blank" rel="external">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0204ic/Cihbjcag.html</a></p><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="/2017/11/24/去除OplayerLite广告提示-越狱机/0ads.png" alt=""></p><p><code>[没什么比实践到的收获有成就感了,它是继续前行的动力之一]</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近在学习逆向相关的实践+踩坑, 庆哥的视频中一个课程是对于OPlayerLite进行进行广告处理了, 因为是去年的课程App也更新了逻辑, 我沿着先辈的道路把坑撸了一把, mark这场一天一夜的战斗.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 
      
    
    </summary>
    
      <category term="reverseEngineering" scheme="http://yoursite.com/categories/reverseEngineering/"/>
    
    
      <category term="实战去除广告" scheme="http://yoursite.com/tags/%E5%AE%9E%E6%88%98%E5%8E%BB%E9%99%A4%E5%B9%BF%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>seleniumANDrequest辅助爬虫</title>
    <link href="http://yoursite.com/2017/11/23/seleniumANDrequest%E8%BE%85%E5%8A%A9%E7%88%AC%E8%99%AB/"/>
    <id>http://yoursite.com/2017/11/23/seleniumANDrequest辅助爬虫/</id>
    <published>2017-11-23T11:42:20.000Z</published>
    <updated>2017-11-24T14:03:10.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>爬虫写多了时候会发现, 很多的时候总是有些问题被阻挡, 虽然越来越多的AI诸如此类的工具也正在破解升级, 但在在小型的爬虫之前,selenium可以帮助我们辅助一些代码层无法越过的坑,拿到完整的cookies, 让客户端对我们身份证验证已通过之后,移交到深层的代码里, 进行操作.</p></blockquote><h3 id="先用selenium拿到最真实的cookies"><a href="#先用selenium拿到最真实的cookies" class="headerlink" title="先用selenium拿到最真实的cookies"></a>先用selenium拿到最真实的cookies</h3><p>似乎这没什么好讲的, 贴下我的代码截图吧…<br>selenium小封装:<br><img src="/2017/11/23/seleniumANDrequest辅助爬虫/login_selenium.png" alt=""></p><p>小爬虫的时候或许都可以跳过这一步, 你可以进行一个长时间的sleep,手工进行登录,填入验证码等</p><h3 id="cookies移交"><a href="#cookies移交" class="headerlink" title="cookies移交"></a>cookies移交</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_session_cookie</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    cookie 移植到 session,方便后续操作</span></div><div class="line"><span class="string">    """</span></div><div class="line">    self.driver.get(<span class="string">'http://url'</span>)</div><div class="line">    <span class="keyword">for</span> subCookie <span class="keyword">in</span> self.driver.get_cookies():</div><div class="line">        self.session.cookies.set(subCookie[<span class="string">u'name'</span>], self.driver.get_cookie(subCookie[<span class="string">u'name'</span>])[<span class="string">'value'</span>])</div></pre></td></tr></table></figure><p>self.driver.get_cookies()  得到是一个数组, 我们遍历这个数组, 拿到name-value , 对移交的session的进行cookies设置. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;爬虫写多了时候会发现, 很多的时候总是有些问题被阻挡, 虽然越来越多的AI诸如此类的工具也正在破解升级, 但在在小型的爬虫之前,selenium可以帮助我们辅助一些代码层无法越过的坑,拿到完整的cookies, 让客户端对我们身份证验证已通过之后,
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>clutch对app进行砸壳</title>
    <link href="http://yoursite.com/2017/11/17/clutch%E5%AF%B9app%E8%BF%9B%E8%A1%8C%E7%A0%B8%E5%A3%B3/"/>
    <id>http://yoursite.com/2017/11/17/clutch对app进行砸壳/</id>
    <published>2017-11-17T01:55:29.000Z</published>
    <updated>2017-11-17T03:17:10.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>逆向学习相关,实战一下对app的砸壳,砸壳必须要越狱手机哦.</p></blockquote><h3 id="什么是壳"><a href="#什么是壳" class="headerlink" title="什么是壳"></a>什么是壳</h3><p>一个App无论是Android还是ios, 或者是PC平台, 为了保护app都会加上一层壳, 加壳的app可能无法被一些IDA之类的工具解析, 那么也就无法搞事情,所以砸壳是必须走的一步,也可以从某助手平台下载已砸壳的, 当然最好用下面的命令确认下先.<br>怎么查看一个app是否有壳, 可以使用下面的命令, 替换为App的二进制文件查看:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">otool -l targetBinary | grep cryptid</div></pre></td></tr></table></figure></p><blockquote><p>得到的结果如果是1则是未砸壳的, 0是已砸壳.<br>还有一种情况是一些App支持多种架构的,可能会展示多个cryptid=1/0, 在哪个平台跑就砸哪个.</p></blockquote><h3 id="确定目标后安装App"><a href="#确定目标后安装App" class="headerlink" title="确定目标后安装App"></a>确定目标后安装App</h3><p>我这里以麦当劳App(听说改名金拱门)为例,从appStore下载安装.</p><h3 id="编译clutch二进制文件"><a href="#编译clutch二进制文件" class="headerlink" title="编译clutch二进制文件"></a>编译clutch二进制文件</h3><p>clutch神器<a href="https://github.com/KJCracks/Clutch" target="_blank" rel="external">下载地址</a>, 下载编译后允许会得到一个二进制文件, 这里不累述哈, 或者你可以直接从我的<a href="https://github.com/Paulswith/ToolsScript" target="_blank" rel="external">git地址</a>clone我编译后的,在clutch_binary文件下.</p><h3 id="拷贝clutch到设备"><a href="#拷贝clutch到设备" class="headerlink" title="拷贝clutch到设备"></a>拷贝clutch到设备</h3><h4 id="连接手机"><a href="#连接手机" class="headerlink" title="连接手机"></a>连接手机</h4><p><img src="/2017/11/17/clutch对app进行砸壳/remote.png" alt=""><br>我这里用iproxy从22映射到2222端口,并整个过程保持. 右边线尝试登录下,默认密码是alpine, 其他情况就自行谷歌帮助,我相信这没什么难度.<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iproxy 2222 22</div></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh root@localhost -p 2222</div></pre></td></tr></table></figure><p>测试连接成功后输入 <code>exit</code> 退出,接着下一步</p><h4 id="scp拷贝到手机"><a href="#scp拷贝到手机" class="headerlink" title="scp拷贝到手机"></a>scp拷贝到手机</h4><p>scp(secure copy) 支持ssh协议远程拷贝, 我们用它拷贝到设备上, 前提是上面的<br>的测试成功了.<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scp -P 2222 ./clutch root@localhost:/usr/bin/</div></pre></td></tr></table></figure></p><p><img src="/2017/11/17/clutch对app进行砸壳/copyto.png" alt=""><br>如果这样子的话就成功了, /usr/bin/默认已经在环境变量查找内, 拷贝到这里可以省事很多多.</p><h4 id="找到目标"><a href="#找到目标" class="headerlink" title="找到目标"></a>找到目标</h4><p>先介绍下clutch用法:<br><img src="/2017/11/17/clutch对app进行砸壳/usafe.png" alt=""><br>推荐<code>ios-deploy -B</code>可以获取bundleID, <code>brew install ios-deploy</code>就可以安装了.<br><img src="/2017/11/17/clutch对app进行砸壳/searchBD.png" alt=""><br>例如我这里的目标是麦当劳app, 尝试搜一下<code>mc</code>,果不其然就是它了.<br>拿到的bundleID就是<code>com.mcdonalds.gma</code><br>(嗯, 还有个grep的方法更简单,但是我真的不知道它是麦当劳, 因为他显示的是Arch,所以靠谱的话就还是上面,BundleID基本会跟名称一直吧)<br><img src="/2017/11/17/clutch对app进行砸壳/nofound.png" alt=""></p><h4 id="开始砸壳"><a href="#开始砸壳" class="headerlink" title="开始砸壳"></a>开始砸壳</h4><p>连接设备<code>ssh root@localhost -p 2222</code><br>进入命令行后输入:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clutch -b com.mcdonalds.gma</div></pre></td></tr></table></figure></p><p><img src="/2017/11/17/clutch对app进行砸壳/succeed.png" alt=""><br>看到这样子的情况的话就是成功了,注意这里粉红色部分, 还给出了砸成功之后的存储路径,我们拷贝下它</p><h4 id="把成果拿到本地验证"><a href="#把成果拿到本地验证" class="headerlink" title="把成果拿到本地验证"></a>把成果拿到本地验证</h4><p>方法有很多, 例如用ifunbox打开上面的路径,直接拿出来, 但是我的9.3.5的没有办法在Ifunbox查看系统目录, 所以用下路的这个方法<br><img src="/2017/11/17/clutch对app进行砸壳/getzip.png" alt=""><br>–&gt; 就是压缩然后scp到本地</p><h3 id="验收"><a href="#验收" class="headerlink" title="验收"></a>验收</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">otool -l tagerBinary | grep cryptid</div></pre></td></tr></table></figure><p><img src="/2017/11/17/clutch对app进行砸壳/6.png" alt=""><br>意料之中的cryptid=0<br>为啥只显示一个,因为它只有一个架构<code>arm_v7</code></p><p><code>[后面的话把逆向的轮子方法一并列出]</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;逆向学习相关,实战一下对app的砸壳,砸壳必须要越狱手机哦.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;什么是壳&quot;&gt;&lt;a href=&quot;#什么是壳&quot; class=&quot;headerlink&quot; title=&quot;什么是壳&quot;&gt;&lt;/a&gt;什么是壳&lt;/h3&gt;
      
    
    </summary>
    
      <category term="reverseEngineering" scheme="http://yoursite.com/categories/reverseEngineering/"/>
    
    
      <category term="砸壳" scheme="http://yoursite.com/tags/%E7%A0%B8%E5%A3%B3/"/>
    
  </entry>
  
  <entry>
    <title>小tip之mac动态背景</title>
    <link href="http://yoursite.com/2017/11/16/%E5%B0%8Ftip%E4%B9%8Bmac%E5%8A%A8%E6%80%81%E8%83%8C%E6%99%AF/"/>
    <id>http://yoursite.com/2017/11/16/小tip之mac动态背景/</id>
    <published>2017-11-16T12:16:58.000Z</published>
    <updated>2017-11-16T13:41:36.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作为一个mac粉, 动态背景怎么能少,现在分享一个小tip,有兴趣的往下看</p></blockquote><h3 id="app安装"><a href="#app安装" class="headerlink" title="app安装"></a>app安装</h3><p>其实事情是一款App就可以搞定了, 但是好像国内搜不到, 我把它压缩传到了我的github上,你可以clone git, 然后在DymaticWallpaper里面找到它,解压并安装即可.<br>git 地址: <a href="https://github.com/Paulswith/ToolsScript.git" target="_blank" rel="external">https://github.com/Paulswith/ToolsScript.git</a></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>安装后, 在屏幕上上方的状态栏可以看到它, 选择点击下载即可, 但它的资源真的很糟糕 </p><ul><li>主要是分辨率太低</li><li>没有对比就没有伤害,对比我待会给你讲的这些资源它真的很逊</li><li>处女座就是挑,大佬们,我说的是我…</li></ul><h3 id="用最酷的视频替换它"><a href="#用最酷的视频替换它" class="headerlink" title="用最酷的视频替换它"></a>用最酷的视频替换它</h3><p><a href="http://a1.phobos.apple.com/us/r1000/000/Features/atv/AutumnResources/videos/entries.json" target="_blank" rel="external">点我跳转到视频源地址</a><br>我在一篇<a href="https://paulswith.github.io/2017/11/16/mac%E4%B8%8A%E7%9A%84Mysql%E8%B8%A9%E5%9D%91%E8%AE%B0/" target="_blank" rel="external">博文</a>中还针对它进数据库存储,因为真是稀缺~ 似乎一段时间还会更新一次, 资源的贡献者是国外的一位大牛<a href="https://github.com/JohnCoates/Aerial" target="_blank" rel="external">johnCoates</a>.<br>可能他的作品是可以用的,但是一直有问题,才用这个app替代.</p><h4 id="选取视频并下载"><a href="#选取视频并下载" class="headerlink" title="选取视频并下载"></a>选取视频并下载</h4><p><img src="/2017/11/16/小tip之mac动态背景/url.png" alt=""><br>浏览器打开下载到本地</p><h4 id="执行替换"><a href="#执行替换" class="headerlink" title="执行替换"></a>执行替换</h4><p>改名为1.mp4(严格大小写),拖到LiveDesktopPro的这个路径,例如我:<br><code>/Applications/LiveDesktop Pro.app/Contents/Resources</code><br><img src="/2017/11/16/小tip之mac动态背景/path.png" alt=""><br>需要权限,输入确认即可<br>一共允许1,2,3,4个文件替换, 依然是改为.mp4的后缀, 不管方法土不土,就是可行.<br>现在重进打开App,选择视频1,即可看到刚才视频了.</p><p>没有找到好的gif转换软件, png将就,这是我选的视频,白天黑夜都使用.<br><img src="/2017/11/16/小tip之mac动态背景/bg.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;作为一个mac粉, 动态背景怎么能少,现在分享一个小tip,有兴趣的往下看&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;app安装&quot;&gt;&lt;a href=&quot;#app安装&quot; class=&quot;headerlink&quot; title=&quot;app安装&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="macTools" scheme="http://yoursite.com/categories/macTools/"/>
    
    
      <category term="macTools" scheme="http://yoursite.com/tags/macTools/"/>
    
  </entry>
  
  <entry>
    <title>mac上的Mysql踩坑记</title>
    <link href="http://yoursite.com/2017/11/16/mac%E4%B8%8A%E7%9A%84Mysql%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/11/16/mac上的Mysql踩坑记/</id>
    <published>2017-11-16T12:05:35.000Z</published>
    <updated>2018-01-20T07:51:13.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前对一个动态背景的接口进行存储处理, 依然是选择mysql存储, 本想着很简单的事情,却在安装的时候各种坑, 所以依然mark下.</p></blockquote><h3 id="安装Mysql"><a href="#安装Mysql" class="headerlink" title="安装Mysql"></a>安装Mysql</h3><p>我选择的是<a href="https://dev.mysql.com/downloads/cluster/" target="_blank" rel="external">MySQL Cluster</a>,community的都是个人使用免费的,还真没具体看什么区别.</p><h3 id="匹配环境"><a href="#匹配环境" class="headerlink" title="匹配环境"></a>匹配环境</h3><p><img src="/2017/11/16/mac上的Mysql踩坑记/env.png" alt=""><br>需要将这个加入到环境里面, 后面安装MySQLDB的时候也需要这个环境的支持的.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export PATH=/usr/local/mysql/bin:$PATH</div></pre></td></tr></table></figure><h3 id="安装后登录密码"><a href="#安装后登录密码" class="headerlink" title="安装后登录密码"></a>安装后登录密码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -u root</div></pre></td></tr></table></figure><p>99%的情况你这样子直接登录就出问题了, 原因是密码不知道.<br>我的解决方法是:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo mysqld_safe --skip-grant-tables&amp;</div></pre></td></tr></table></figure><p>这时候再:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -u root mysql</div></pre></td></tr></table></figure><h3 id="python安装MySQLdb"><a href="#python安装MySQLdb" class="headerlink" title="python安装MySQLdb"></a>python安装MySQLdb</h3><p>使用python操作mysql的时候需要一个库叫做<code>MySQLdb</code>,坑的是安装的时候, 原因是不知道它具体在pip 安装是什么名字的, 一直用MySQLdb怎么也找不到. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip install mysql-python</div></pre></td></tr></table></figure><p>是的,没了.就这样子就可以了. </p><h3 id="python操作mysql"><a href="#python操作mysql" class="headerlink" title="python操作mysql"></a>python操作mysql</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line">__author = <span class="string">'dobby 2017.11.2'</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> requests</div><div class="line"><span class="keyword">import</span> simplejson <span class="keyword">as</span> json</div><div class="line"><span class="keyword">import</span>  MySQLdb</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#step ------------------------connect mysql----------------</span></div><div class="line">db = MySQLdb.connect(host=<span class="string">'localhost'</span>,port=<span class="number">3306</span>,</div><div class="line">                     user=<span class="string">'root'</span>, db=<span class="string">'owner'</span>, charset=<span class="string">'utf8'</span>)   </div><div class="line">                    <span class="comment"># 打开数据库连接,我是没有密码的连接</span></div><div class="line">cursor = db.cursor()      </div><div class="line"><span class="comment"># 使用cursor()方法获取操作游标,因为这是一个c的api, 后面的操作都是基于这个指针</span></div><div class="line">cursor.execute(<span class="string">'show tables'</span>)        </div><div class="line"><span class="comment">#只是全部的执行方法</span></div><div class="line">data = cursor.fetchone()                </div><div class="line"><span class="comment">#这个命令能拿到上条执行方法后的返回值 ,类似os.read()吧</span></div><div class="line"><span class="keyword">print</span> data</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#step ------------------------get  data----------------</span></div><div class="line">session = requests.session()</div><div class="line">req =session.get(<span class="string">'http://a1.phobos.apple.com/us/r1000\</span></div><div class="line"><span class="string">                 /000/Features/atv/AutumnResources/videos/entries.json'</span>)</div><div class="line"><span class="keyword">if</span> req.content <span class="keyword">and</span> int(req.status_code) == <span class="number">200</span>:</div><div class="line">    <span class="keyword">print</span> <span class="string">'get all data succeed.'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#step -----------------------handler data-------------</span></div><div class="line">api_data_list = json.loads(req.content)</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="keyword">for</span> dict_data <span class="keyword">in</span> api_data_list:</div><div class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> dict_data[<span class="string">'assets'</span>]:</div><div class="line">            <span class="comment"># 生成mysql数据写入的sql语句</span></div><div class="line">            sql = <span class="string">"INSERT INTO wallpaper values('&#123;a&#125;','&#123;b&#125;','&#123;c&#125;','&#123;d&#125;','&#123;e&#125;')"</span>.\</div><div class="line">                format(a=item[<span class="string">'url'</span>],b=item[<span class="string">'accessibilityLabel'</span>],c=item[<span class="string">'type'</span>],</div><div class="line">                       d=item[<span class="string">'id'</span>],e=item[<span class="string">'timeOfDay'</span>])</div><div class="line">            <span class="comment"># 执行语句</span></div><div class="line">            cursor.execute(sql)</div><div class="line">            data = cursor.fetchone()</div><div class="line">            <span class="keyword">print</span> data</div><div class="line">        <span class="comment"># ******这是重点, 必须对数据进行总提交</span></div><div class="line">        db.commit()</div><div class="line"><span class="keyword">except</span>:</div><div class="line">    db.rollback() <span class="comment">#避免出现中断的情况, 如果有就回滚</span></div><div class="line">db.close()  <span class="comment">#关闭数据库,避免数据丢失....</span></div></pre></td></tr></table></figure><blockquote><p>坑之类代码都在里面了, 就这样子吧,好像没什么料,主要还是mark下….</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;之前对一个动态背景的接口进行存储处理, 依然是选择mysql存储, 本想着很简单的事情,却在安装的时候各种坑, 所以依然mark下.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;安装Mysql&quot;&gt;&lt;a href=&quot;#安装Mysql&quot; cla
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>ios重签名脚本的0到1</title>
    <link href="http://yoursite.com/2017/11/14/ios%E9%87%8D%E7%AD%BE%E5%90%8D%E8%84%9A%E6%9C%AC%E7%9A%840%E5%88%B01/"/>
    <id>http://yoursite.com/2017/11/14/ios重签名脚本的0到1/</id>
    <published>2017-11-14T12:03:21.000Z</published>
    <updated>2018-01-20T07:51:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对重签名脚本进行了规范的踩坑 , 挤出一个微笑后写下这篇博文<br>感谢Google, 感谢我生涩的swift 之阅读IosAppResigner源码</p></blockquote><h3 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h3><p><img src="/2017/11/14/ios重签名脚本的0到1/sign_profile.png" alt=""></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./resign.sh /Users/dobby/Desktop/微信-已砸壳.ipa  /Users/dobby/Desktop/original.mobileprovision  com.weixin.resign</div></pre></td></tr></table></figure><ul><li>$1 需要砸壳过的ipa,从PP助手下载即可</li><li>$2 .mobileprovision 这个是证书对应的文件,也可以指定证书Xcode的product下也会生成</li><li>$3 是否修改bundleID,默认是原先的</li></ul><p><img src="/2017/11/14/ios重签名脚本的0到1/signstr.png" alt=""></p><blockquote><p>脚本内部需要写入一个一个签名字符串,可以通过下方的命令拿到<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">security find-identity -v -p codesigning</div></pre></td></tr></table></figure></p><p>若是cryptid显示为0,非砸壳为1. 砸壳虽不影响签名的成功率, 但是我试了下可安装,但不可使用. 可google下砸壳方法自行砸壳.下面是查看cryptid的命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">otool -l ./腾讯手机管家-来电防骚扰的QQ安全助手\(正版\)/Payload/MQQSecure.app/MQQSecure | grep cryptid</div></pre></td></tr></table></figure></p></blockquote><h3 id="mobileProvision生成Entitlements-plist"><a href="#mobileProvision生成Entitlements-plist" class="headerlink" title="mobileProvision生成Entitlements.plist"></a>mobileProvision生成Entitlements.plist</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">security cms -D -i $provision &gt; ProvisionProfile.plist </div><div class="line">/usr/libexec/PlistBuddy -x -c "Print Entitlements" ProvisionProfile.plist &gt; $tempPlace/Entitlements.plist</div></pre></td></tr></table></figure><p>用该方法生成一个Entitlements.plist文件,之前还没找到这么快捷的生成方法, 有个土方法自己折腾出来的也是可行的,详见<a href="https://paulswith.github.io/2017/11/14/plist%E6%96%87%E4%BB%B6-%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C/" target="_blank" rel="external">plist文件-在脚本中的操作</a></p><h3 id="mobileProvision拷贝为embedded-mobileprovision"><a href="#mobileProvision拷贝为embedded-mobileprovision" class="headerlink" title="mobileProvision拷贝为embedded.mobileprovision"></a>mobileProvision拷贝为embedded.mobileprovision</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp $provision $appPlace/embedded.mobileprovision</div></pre></td></tr></table></figure><h3 id="是否概要更改BundleID"><a href="#是否概要更改BundleID" class="headerlink" title="是否概要更改BundleID"></a>是否概要更改BundleID</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if [[ $3 ]]; then</div><div class="line">plutil -replace CFBundleIdentifier -string "$3" $appPlace/Info.plist</div><div class="line">reBundleID=`plutil -p $appPlace/Info.plist | grep 'CFBundleIdentifier' `</div><div class="line">echo "Log info : you wanna replace to: $&#123;reBundleID&#125;"</div><div class="line">fi</div></pre></td></tr></table></figure><p>默认的时候是原先的, BundleID安装到设备上是唯一的,若是原版本共存,必须要更改</p><h3 id="删除影响签名文件"><a href="#删除影响签名文件" class="headerlink" title="删除影响签名文件"></a>删除影响签名文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">plutil -remove CFBundleREsourceSpecification $appPlace/Info.plist   #删除签名源文件相关</div><div class="line">rm -rf $appPlace/Watch  #发现watch插件必现失败,这个必须删除了</div><div class="line">rm -rf $appPlace/PlugIns #发现PlugIns插件必现失败,这个必须删除了,就算下面重签也不管的, 坑超多</div><div class="line">codesignInfo=`find $appPlace -name "CodeResources" `</div><div class="line">for i in $codesignInfo; do</div><div class="line">rm -f $i</div><div class="line">done</div></pre></td></tr></table></figure><ul><li>对Info.plist里面的CFBundleREsourceSpecification这个key删除,具体不知道做了什么,IosAppSigner也这么做了</li><li>Watch和Plugins这两个文件,我曾试过对他们都进行重签名, 但依然不管用, 相关坑大概是独立性,可以跳转到<a href="https://nianxi.net/ios/dump-decrypted-ios-app-extensions.html" target="_blank" rel="external">念茜女神</a>的博文了解</li><li>源文件的_CodeSignature/CodeResources也进行了全局删除,签名后会自动生成这个文件</li></ul><h3 id="开始重签"><a href="#开始重签" class="headerlink" title="开始重签"></a>开始重签</h3><h4 id="第一步-相关lib-framework签名"><a href="#第一步-相关lib-framework签名" class="headerlink" title="第一步,相关lib-framework签名"></a>第一步,相关lib-framework签名</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">allShouldSign=` find $appPlace -name "*.appex" &amp;&amp; find $appPlace  -name "*.framework" &amp;&amp; find $appPlace  -name "*.dylib" &amp;&amp; find $appPlace/* -name "*.app" ` #最上层的先不签</div><div class="line">for i in $allShouldSign; do</div><div class="line">codesign -fs "$&#123;signStr&#125;" --no-strict --entitlements=/tmp/project_resign/Entitlements.plist $i</div><div class="line">done</div></pre></td></tr></table></figure><ul><li>对上方类型都进行一篇搜索,得到绝对路径后进行重签名<br><img src="/2017/11/14/ios重签名脚本的0到1/type.png" alt=""><blockquote><p>这是iosAppResigner中,作者对着全部的类型都检索了一遍,我并完全覆盖,如果你踩到了坑,可以试试把类型都加上</p></blockquote></li></ul><h4 id="核心包签名"><a href="#核心包签名" class="headerlink" title="核心包签名"></a>核心包签名</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">codesign -vvv -fs "$signStr" --no-strict --entitlements=/tmp/project_resign/Entitlements.plist $appPlace</div></pre></td></tr></table></figure><h3 id="打包为ipa"><a href="#打包为ipa" class="headerlink" title="打包为ipa"></a>打包为ipa</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd $tempPlace</div><div class="line">zip -qry sign.ipa ./Payload</div><div class="line">mv $tempPlace/sign.ipa ~/Desktop</div></pre></td></tr></table></figure><ul><li>因为打包的时候是递归形式的, 指定绝对路径会踩坑,注意就行</li></ul><h3 id="安装试试"><a href="#安装试试" class="headerlink" title="安装试试"></a>安装试试</h3><p><img src="/2017/11/14/ios重签名脚本的0到1/install.png" alt=""></p><p><a href="https://github.com/Paulswith/ToolsScript/tree/master/iosResign" target="_blank" rel="external">- - -附源码github链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;对重签名脚本进行了规范的踩坑 , 挤出一个微笑后写下这篇博文&lt;br&gt;感谢Google, 感谢我生涩的swift 之阅读IosAppResigner源码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Profile&quot;&gt;&lt;a href=&quot;#Pro
      
    
    </summary>
    
      <category term="Unix" scheme="http://yoursite.com/categories/Unix/"/>
    
    
      <category term="iosDev" scheme="http://yoursite.com/tags/iosDev/"/>
    
  </entry>
  
  <entry>
    <title>plist文件-在脚本中的操作</title>
    <link href="http://yoursite.com/2017/11/14/plist%E6%96%87%E4%BB%B6-%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2017/11/14/plist文件-在脚本中的操作/</id>
    <published>2017-11-14T11:30:39.000Z</published>
    <updated>2017-11-14T12:03:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>背景是写一个自动签名的脚本, 真的是从0到1的踩坑记, 其中需要对.provision文件进行签名信息截取, 并生成.plist文件</p></blockquote><h3 id="method-ONE"><a href="#method-ONE" class="headerlink" title="method_ONE"></a>method_ONE</h3><h4 id="内容截取并保存临时文件中"><a href="#内容截取并保存临时文件中" class="headerlink" title="内容截取并保存临时文件中"></a>内容截取并保存临时文件中</h4><p>先看看.provision文字长什么样子, 我截取了其中一部分展示的信息,其中我们要的内容是从dict到dict之间<br><img src="/2017/11/14/plist文件-在脚本中的操作/all.png" alt=""><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">security cms -D -i ./original.mobileprovision | grep --after-context=20 "&lt;key&gt;Entitlements&lt;/key&gt;"  &gt; /tmp/tmp_provision</div></pre></td></tr></table></figure></p><p>读取匹配的信息,并保存到/tmp/tmp_provision这个文件中</p><h4 id="python进行正则匹配-过滤dict之后的内容"><a href="#python进行正则匹配-过滤dict之后的内容" class="headerlink" title="python进行正则匹配,过滤dict之后的内容"></a>python进行正则匹配,过滤dict之后的内容</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">provision=`python -c "from re import findall,compile,S;data=open('/tmp/tmp_provision','r').read();print findall(compile(r'&lt;dict&gt;.*&lt;/dict&gt;',S),data)[0];"`</div></pre></td></tr></table></figure><h4 id="最后重定向到一个-plist文件中"><a href="#最后重定向到一个-plist文件中" class="headerlink" title="最后重定向到一个.plist文件中"></a>最后重定向到一个.plist文件中</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo '&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;&lt;plist version="1.0"&gt;'$provision'&lt;/plist&gt;' &gt; Entitlements.plist</div></pre></td></tr></table></figure><blockquote><p>这个方法虽然可以, 但是其中第三部, 必须要格外注意字符的使用, 不然就格式不对,导致重定向出来的无法识别为.plist</p></blockquote><h3 id="method-TWO"><a href="#method-TWO" class="headerlink" title="method_TWO"></a>method_TWO</h3><h4 id="重定向为一个-plist"><a href="#重定向为一个-plist" class="headerlink" title="重定向为一个.plist"></a>重定向为一个.plist</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">security cms -D -i ./original.mobileprovision &gt; ProvisionProfile.plist</div></pre></td></tr></table></figure><p>查看到全部的信息, 重定向为一个ProvisionProfile.plist,还没有过滤</p><h4 id="提取内容生成"><a href="#提取内容生成" class="headerlink" title="提取内容生成"></a>提取内容生成</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/libexec/PlistBuddy -x -c "Print Entitlements" ProvisionProfile.plist &gt; Entitlements.plist</div></pre></td></tr></table></figure><p>直接将里面的子项Entitlements拿出来,生成一个新的Entitlements.plist</p><blockquote><p>这个方法比上面的稳妥不知道多少倍, 但是第一个的方法是自己钻研</p></blockquote><h3 id="plist文件的增删改查"><a href="#plist文件的增删改查" class="headerlink" title=".plist文件的增删改查"></a>.plist文件的增删改查</h3><p><img src="/2017/11/14/plist文件-在脚本中的操作/plutil.png" alt=""><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">plutil -p ./ProvisionProfile.plist  #查看</div><div class="line">plutil -insert Insert -string "insert data here" ./ProvisionProfile.plist    #增</div><div class="line">plutil -replace Insert -string "change  data here" ./ProvisionProfile.plist  #替换</div></pre></td></tr></table></figure></p><blockquote><p>列举的就诸如此类,plutil是一个.plist官方推荐的好工具</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;背景是写一个自动签名的脚本, 真的是从0到1的踩坑记, 其中需要对.provision文件进行签名信息截取, 并生成.plist文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;method-ONE&quot;&gt;&lt;a href=&quot;#method-ON
      
    
    </summary>
    
      <category term="Unix" scheme="http://yoursite.com/categories/Unix/"/>
    
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本中如何捕获异常</title>
    <link href="http://yoursite.com/2017/11/14/shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2017/11/14/shell脚本中如何捕获异常/</id>
    <published>2017-11-14T10:56:50.000Z</published>
    <updated>2017-11-14T11:14:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在高级语言的时候,我们可以使用捕获异常的语句, 进行catch, 并和谐的处理, 但是shell是没有类似keyword的, 如何解决?<br>答案是 <code>#?</code> : <code>用于捕获上一条命令的状态,0的状态为正常,1为异常</code><br>自己在整理shell的时候遇到一些坑, 把它的规范列一下</p></blockquote><h3 id="和echo输出命令要注意"><a href="#和echo输出命令要注意" class="headerlink" title="#?和echo输出命令要注意"></a>#?和echo输出命令要注意</h3><p><img src="/2017/11/14/shell脚本中如何捕获异常/echo1.png" alt=""><br>这是一条echo输出命令,命令处于``之中,输出后执行. 但是命令是错误,执行的话会抛错误,也就是<code>echo $?</code>应该给到是1<br>但是看看执行结果:<br><img src="/2017/11/14/shell脚本中如何捕获异常/echo2.png" alt=""><br>看到输出的结果是0, 原因在于<code>echo</code>上, <code>echo</code>包了这一层命令, 只要<code>echo</code>直接将这命令打印在终端, 就是完整的完成工作,根本没有异常可言.</p><h3 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h3><p>当然是去除<code>echo</code>直接输出, 但是还是要注意的是, <code>$?</code>仅仅提示是上一条,这里必须十分谨慎.列下能捕获到异常:<br><img src="/2017/11/14/shell脚本中如何捕获异常/fix1.png" alt=""><br><img src="/2017/11/14/shell脚本中如何捕获异常/fix2.png" alt=""><br>可以看到输出是1了, 确认命令使用没问题后,就可以进行逻辑处理.</p><h3 id="避免"><a href="#避免" class="headerlink" title="避免"></a>避免</h3><p>这是完整的逻辑代码:<br><img src="/2017/11/14/shell脚本中如何捕获异常/full1.png" alt=""><br>更好的避免, 将允许的条件, 并到逻辑与:<br><img src="/2017/11/14/shell脚本中如何捕获异常/full2.png" alt=""></p><p><code>[shell大法好]</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在高级语言的时候,我们可以使用捕获异常的语句, 进行catch, 并和谐的处理, 但是shell是没有类似keyword的, 如何解决?&lt;br&gt;答案是 &lt;code&gt;#?&lt;/code&gt; : &lt;code&gt;用于捕获上一条命令的状态,0的状态为正常,1为异
      
    
    </summary>
    
      <category term="Unix" scheme="http://yoursite.com/categories/Unix/"/>
    
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>OC中常用的延迟执行代码方法</title>
    <link href="http://yoursite.com/2017/11/08/OC%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BB%B6%E8%BF%9F%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2017/11/08/OC中常用的延迟执行代码方法/</id>
    <published>2017-11-08T11:12:41.000Z</published>
    <updated>2017-11-08T11:35:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写于篇头"><a href="#写于篇头" class="headerlink" title="写于篇头"></a>写于篇头</h3><blockquote><p>很多时候我们在代码中延迟执行代码, 情况分很多种,列一下我常用的在哪些情况</p></blockquote><h3 id="performSelector"><a href="#performSelector" class="headerlink" title="performSelector"></a>performSelector</h3><p><img src="/2017/11/08/OC中常用的延迟执行代码方法/1.png" alt=""></p><blockquote><p>很多时候用于延迟展示动画,例如转场动画等, 小延迟来产生的视觉误差,达到动画之美.  </p></blockquote><h3 id="NSTimer-scheduled"><a href="#NSTimer-scheduled" class="headerlink" title="NSTimer scheduled"></a>NSTimer scheduled</h3><p><img src="/2017/11/08/OC中常用的延迟执行代码方法/2.png" alt=""></p><blockquote><p>常用来一些页面的定时器, 例如一些App上的广告倒计时, NSTimer可以定时执行一些动作. 且repeats参数,可以决定这里的循环. </p></blockquote><p><img src="/2017/11/08/OC中常用的延迟执行代码方法/t2.png" alt=""></p><blockquote><p>注意Timer本身是被Runloop强引用的,所以如果是定义为property,用weak修饰.<br>然后可在<code>invalidate</code>中停止和销毁</p></blockquote><h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><p><img src="/2017/11/08/OC中常用的延迟执行代码方法/3.png" alt=""></p><blockquote><p>gcd中可以指定线程, 常用来做异步的处理,不阻塞主线的操作, 例如延迟网络加载so on. </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;写于篇头&quot;&gt;&lt;a href=&quot;#写于篇头&quot; class=&quot;headerlink&quot; title=&quot;写于篇头&quot;&gt;&lt;/a&gt;写于篇头&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;很多时候我们在代码中延迟执行代码, 情况分很多种,列一下我常用的在哪些情况&lt;/p&gt;
&lt;/block
      
    
    </summary>
    
      <category term="Objective-C" scheme="http://yoursite.com/categories/Objective-C/"/>
    
    
      <category term="iosDev" scheme="http://yoursite.com/tags/iosDev/"/>
    
  </entry>
  
  <entry>
    <title>brewupgrade-提示ruby版本低</title>
    <link href="http://yoursite.com/2017/11/08/brewupgrade-%E6%8F%90%E7%A4%BAruby%E7%89%88%E6%9C%AC%E4%BD%8E/"/>
    <id>http://yoursite.com/2017/11/08/brewupgrade-提示ruby版本低/</id>
    <published>2017-11-08T10:40:41.000Z</published>
    <updated>2017-11-08T11:14:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="干嘛写"><a href="#干嘛写" class="headerlink" title="干嘛写?"></a>干嘛写?</h3><blockquote><p>mac自带了很多的开发环境,ruby python java so on~~, 但版本有时候低了, 又不能直接升级系统的这些,昨天brew upgrade的时候提示了ruby版本低,mark这个小tip</p></blockquote><h3 id="Error-like-that"><a href="#Error-like-that" class="headerlink" title="Error like that"></a>Error like that</h3><p><img src="/2017/11/08/brewupgrade-提示ruby版本低/tishi.png" alt=""></p><blockquote><p>你在<code>brew upgrade</code>的时候报了这样的错误</p></blockquote><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p><img src="/2017/11/08/brewupgrade-提示ruby版本低/old_version.png" alt=""></p><blockquote><p>官网都到2.4+了,确实older</p></blockquote><h3 id="which"><a href="#which" class="headerlink" title="which"></a>which</h3><p><img src="/2017/11/08/brewupgrade-提示ruby版本低/which_ruby.png" alt=""></p><blockquote><p>因为是系统自带,which看到是在/usr/bin/下的</p></blockquote><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p><img src="/2017/11/08/brewupgrade-提示ruby版本低/resove.png" alt=""></p><blockquote><p>可以试试, 两行, 完美解决,当然也会有解决不了的, 往下看</p></blockquote><h3 id="怎么解决的"><a href="#怎么解决的" class="headerlink" title="怎么解决的?"></a>怎么解决的?</h3><p><img src="/2017/11/08/brewupgrade-提示ruby版本低/find.png" alt=""></p><blockquote><p>可以从结果完美运行知道, brew 运行的时候不会指定要哪个目录下的ruby,直接是ruby —</p><p>没有解决的是什么情况呢? 这时候你which ruby看到的应该与我不同, 它依然显示是/usr/bin/下面的</p><p>因为 <code>[环境变量在同样名词的情况下, 是会存在覆盖的. ]</code>, 你可以打开你的.bash_profile 或 .zshrc 配置文件下, export PATH=<strong>*</strong>, 是不是把/usr/local/bin/ 的顺序, 放在了/usr/bin的前面了. </p></blockquote><h3 id="mac大法好"><a href="#mac大法好" class="headerlink" title="mac大法好"></a>mac大法好</h3><blockquote><p>小tip,没什么料, 点点滴滴点点</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;干嘛写&quot;&gt;&lt;a href=&quot;#干嘛写&quot; class=&quot;headerlink&quot; title=&quot;干嘛写?&quot;&gt;&lt;/a&gt;干嘛写?&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;mac自带了很多的开发环境,ruby python java so on~~, 但版本有时候低了, 又
      
    
    </summary>
    
      <category term="Unix" scheme="http://yoursite.com/categories/Unix/"/>
    
    
      <category term="brewupgradeError" scheme="http://yoursite.com/tags/brewupgradeError/"/>
    
  </entry>
  
</feed>
